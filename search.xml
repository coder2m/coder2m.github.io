<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang微服务开发-grpc</title>
      <link href="/posts/golang/5f3710bf.html"/>
      <url>/posts/golang/5f3710bf.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 09:17:11 GMT+0800 (GMT+08:00) --><h1 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h1><p>grpc官网：<a href="https://www.grpc.io/" target="_blank" rel="noopener">https://www.grpc.io/</a></p><blockquote><p>A high-performance, open-source universal RPC framework</p></blockquote><p>这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?RPC(remote procedure call 远程过程调用),所谓RPC框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</p><p>RPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082403.png" alt=""></p><p>RPC调用过程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082506.png" alt=""></p><p>GRPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082558.png" alt=""></p><p>性能对比可以查看这篇文章：<a href="https://blog.csdn.net/xuduorui/article/details/77938644" target="_blank" rel="noopener">https://blog.csdn.net/xuduorui/article/details/77938644</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>先安装Protobuf 编译器 protoc，下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p><p>Protobuf插件库安装：</p><pre><code class="golang">// gRPC运行时接口编解码支持库go get -u github.com/golang/protobuf/proto// 从 Proto文件(gRPC接口描述文件) 生成 go文件 的编译器插件go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>go依赖包</p><pre><code class="golang">go get -u google.golang.org/grpc</code></pre><h1 id="定义服务，编写proto文件"><a href="#定义服务，编写proto文件" class="headerlink" title="定义服务，编写proto文件"></a>定义服务，编写proto文件</h1><p>编写proto文件的语法什么的，我后面会单独出一篇文章。这里就不多说语法了。</p><pre><code class="proto">syntax = &quot;proto3&quot;;package study;//  请求参数message Token {    string jwtToken = 1; //1为字段顺序 required必须    int64 timeStamp = 2;}//  返回参数message TokenR {    bool IsLogin = 1;}//  定义服务Auth//  服务方法CheckToken//  Token传入的值//  TokenR输出的值//  生成兼容grpc的go文件//  protoc --go_out=plugins=grpc:. *.protoservice Auth {    rpc CheckToken (Token) returns (TokenR);}</code></pre><h1 id="生成兼容grpc的go文件"><a href="#生成兼容grpc的go文件" class="headerlink" title="生成兼容grpc的go文件"></a>生成兼容grpc的go文件</h1><pre><code class="golang">protoc --go_out=plugins=grpc:. *.proto</code></pre><p>生成了对应的pb文件：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710083457.png" alt=""></p><h1 id="编写服务端"><a href="#编写服务端" class="headerlink" title="编写服务端"></a>编写服务端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;net&quot;)type AuthImp struct {}func (a *AuthImp) CheckToken(ctx context.Context, token *study.Token) (*study.TokenR, error) {   s := token.JwtToken   fmt.Println(s)   /**   一些列处理   */   //数据的返回   res := new(study.TokenR)   res.IsLogin = true   return res, nil}func main() {   server := grpc.NewServer()   //注册   study.RegisterAuthServer(server, new(AuthImp))   lis, err := net.Listen(&quot;tcp&quot;, &quot;:8091&quot;)   if err != nil {      panic(err.Error())   }   _ = server.Serve(lis)}</code></pre><h1 id="编写客户端"><a href="#编写客户端" class="headerlink" title="编写客户端"></a>编写客户端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;time&quot;)func main() {   //客户端连接   conn, err := grpc.Dial(&quot;localhost:8091&quot;, grpc.WithInsecure())   if err != nil {      panic(err.Error())   }   defer conn.Close()   authServiceClient := study.NewAuthClient(conn)   request := study.Token{      TimeStamp: time.Now().Unix(),      JwtToken:  &quot;3213213&quot;,   }   checkTokenClient, err := authServiceClient.CheckToken(context.Background(), &amp;request)   fmt.Println(checkTokenClient.IsLogin)}</code></pre><p>这样就完成了最简单的grpc功能。</p><p>这样的rpc接口只能在程序之间进行调用，但是我们最后的服务需要提供给用户使用，需要的是http请求。这里有几个方案进行解决：</p><blockquote><p>1.编写专门的提供http的web服务，web服务充当客户端，调用grpc。</p></blockquote><blockquote><p>2.使用GRPC Gateway: <a href="https://github.com/grpc-ecosystem/grpc-gateway/" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/grpc-gateway/</a></p></blockquote><blockquote><p>3.使用第三方拓展：<a href="https://github.com/vaporz/turbo" target="_blank" rel="noopener">https://github.com/vaporz/turbo</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> grpc </tag>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现一致性Hash算法</title>
      <link href="/posts/golang/6a0c048e.html"/>
      <url>/posts/golang/6a0c048e.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 22:25:12 GMT+0800 (GMT+08:00) --><h1 id="什么是一致性Hash算法"><a href="#什么是一致性Hash算法" class="headerlink" title="什么是一致性Hash算法"></a>什么是一致性Hash算法</h1><p>一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709195951.png" alt=""></p><p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p><p>我们把这个由2的32次方个点组成的圆环称为hash环。</p><p>假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意</p><blockquote><p>hash(服务器A的IP地址) % 2^32</p></blockquote><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201526.png" alt=""></p><p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中。所以现在的hash环：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201713.png" alt=""></p><p>这样我们的服务器就映射到了hash环上，现在我们同理也就可以把我们需要访问的对象也放在hash环上。</p><p>假设我们现在需要分别在三个服务器上放缓存的文件，我们就使用文件的名字作为计算hash的key：</p><blockquote><p>hash(文件名) % 2^32</p></blockquote><p>这样也能计算一个值，也就能映射到对应的hash环上。现在我们的hash环就变成了这个样子：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709202336.png" alt=""></p><p>计算出来了文件的hash值，下一步就是觉得那个服务器存储这个对象了。这里规定是：从计算出来的位置开始向顺时针方向遇到的第一个服务器，进行存储。所以这里文件就会存储在服务器B上。</p><p>这就是一致性hash算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>这里我们假设，我们的服务器B突然失效了,我们上面例子中的文件就会存储到服务器c中，这样就算是缓存失效。但是这里服务器失效的是A,就对上面例子中的文件不会有任何的影响。使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。这就是一致性哈希算法所体现出的优点。</p><h1 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h1><p>理想情况下我们的3个服务器是如上图所示，均匀的分布在hash环上，但是理想往往和现实差距很大：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203438.png" alt=""></p><p>实际上映射中，服务器可能会被映射成这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203659.png" alt=""></p><p>这种情况下缓存的对象很有可能大部分集中缓存在某一台服务器。这就很难受了。这就是hash环的偏斜。那么，我们应该怎样防止hash环的偏斜呢？</p><h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>虚拟节点就是来解决hash环偏斜的问题的。顾名思义就是在hash环上创建每个服务器的副本，是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点，创建副本后的hash环就变成了这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709204300.png" alt=""></p><p>这样就解决了偏移问题。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p><h1 id="Golang中实现hash环"><a href="#Golang中实现hash环" class="headerlink" title="Golang中实现hash环"></a>Golang中实现hash环</h1><pre><code class="golang">package hashimport (    &quot;errors&quot;    &quot;hash/crc32&quot;    &quot;sort&quot;    &quot;strconv&quot;    &quot;sync&quot;)//声明新切片类型type units []uint32//返回切片长度func (x units) Len() int {    return len(x)}//比对两个数大小func (x units) Less(i, j int) bool {    return x[i] &lt; x[j]}//切片中两个值的交换func (x units) Swap(i, j int) {    x[i], x[j] = x[j], x[i]}//创建结构体保存一致性hash信息type ConsistentHash struct {    //hash环，key为哈希值，值存放节点的信息    circle map[uint32]string    //已经排序的节点hash切片    sortedHashes units    //虚拟节点个数，用来增加hash的平衡性    VirtualNode int    //map 读写锁    sync.RWMutex}//创建一致性hash算法结构体，设置默认节点数量func NewConsistent(nodeNum int) *ConsistentHash {    return &amp;ConsistentHash{        //初始化变量        circle: make(map[uint32]string),        //设置虚拟节点个数        VirtualNode: nodeNum,    }}//自动生成key值func (c *ConsistentHash) generateKey(element string, index int) string {    //副本key生成逻辑    return element + strconv.Itoa(index)}//获取hash位置 计算key 在hash环中对应的位置func (c *ConsistentHash) hashKey(key string) uint32 {    //当长度不够填充    if len(key) &lt; 64 {        //声明一个数组长度为64        var tmpList [64]byte        //拷贝数据到数组中        copy(tmpList[:], key)        //使用IEEE 多项式返回数据的CRC-32校验和        return crc32.ChecksumIEEE(tmpList[:len(key)])    }    return crc32.ChecksumIEEE([]byte(key))}//更新排序，方便查找 因为后面我们使用的是sort.Search进行查找 sort.Search使用的是二分法进行查找，所以这里需要排序func (c *ConsistentHash) updateSortedHashes() {    hashes := c.sortedHashes[:0]    //判断切片容量，是否过大，如果过大则重置    if cap(c.sortedHashes)/(c.VirtualNode*4) &gt; len(c.circle) {        hashes = nil    }    //添加hashes    for k := range c.circle {        hashes = append(hashes, k)    }    //对所有节点hash值进行排序，    //方便之后进行二分查找    sort.Sort(hashes)    //重新赋值    c.sortedHashes = hashes}//向hash环中添加节点func (c *ConsistentHash) Add(element string) {    //加锁    c.Lock()    //解锁    defer c.Unlock()    c.add(element)}//添加节点func (c *ConsistentHash) add(element string) {    //循环虚拟节点，设置副本    for i := 0; i &lt; c.VirtualNode; i++ {        //根据生成的节点添加到hash环中        c.circle[c.hashKey(c.generateKey(element, i))] = element    }    //更新排序    c.updateSortedHashes()}//删除节点func (c *ConsistentHash) remove(element string) {    for i := 0; i &lt; c.VirtualNode; i++ {        delete(c.circle, c.hashKey(c.generateKey(element, i)))    }    c.updateSortedHashes()}//删除一个节点func (c *ConsistentHash) Remove(element string) {    c.Lock()    defer c.Unlock()    c.remove(element)}//顺时针查找最近的节点func (c *ConsistentHash) search(key uint32) int {    //查找算法    f := func(x int) bool {        return c.sortedHashes[x] &gt; key    }    //使用&quot;二分查找&quot;算法来搜索指定切片满足条件的最小值    i := sort.Search(len(c.sortedHashes), f)    //如果超出范围则设置i=0    if i &gt;= len(c.sortedHashes) {        i = 0    }    return i}//根据数据标示获取最近的服务器节点信息func (c *ConsistentHash) Get(name string) (string, error) {    //添加锁    c.RLock()    //解锁    defer c.RUnlock()    //如果为零则返回错误    if len(c.circle) == 0 {        return &quot;&quot;, errors.New(&quot;hash环没有数据&quot;)    }    //计算hash值    key := c.hashKey(name)    i := c.search(key)    return c.circle[c.sortedHashes[i]], nil}</code></pre><p>这样就很简单的实现了golong的一致性hash。</p><blockquote><p>这里提一下，为什么是2^32呢?因为这个算法的出现就算为了解决分布式问题，所以在分布式中基本上存储的就算服务器的ip，IPv4的地址是4组8位2进制数组成，所以用2^32可以保证每个IP地址会有唯一的映射。</p></blockquote><p>参考连接：<a href="https://www.cnblogs.com/williamjie/p/9477852.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9477852.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> 一致性Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现依赖注入+gin</title>
      <link href="/posts/golang/8f49d9e3.html"/>
      <url>/posts/golang/8f49d9e3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 11:10:46 GMT+0800 (GMT+08:00) --><h1 id="Go实现依赖注入"><a href="#Go实现依赖注入" class="headerlink" title="Go实现依赖注入"></a>Go实现依赖注入</h1><p>最近在使用go开发的时候，发现构建系统依赖树非常繁琐，需要手动去new很多对象，又手工代码将它们拼接起来，写了一堆非常冗繁的代码。之前在laravel的使用中有其强大的ioc，都没有这方面的困扰。就在想golang中有没有好用的依赖注入方案，查询资料，发现了facebook团队开源的inject。GitHub地址：<a href="http://github.com/facebookgo/inject" target="_blank" rel="noopener">http://github.com/facebookgo/inject</a></p><p>没有依赖注入的系统：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709104638.png" alt=""></p><p>在代码上的表现：</p><pre><code class="golang">func NewUserRepository() UserRepositoryImp {    return &amp;UserManagerRepository{        Db: models.MysqlHandler,    }}func NewUserServices(repository repositories.UserRepositoryImp) UserServiceImp {    return &amp;UserService{repository}}func NewUserController(userServices services.UserServiceImp) UserImp {    return &amp;UserController{UserServices: userServices}}repository := repositories.NewUserRepository()userServices := services.NewUserServices(repository)controller := controllers.NewUserController(userServices)</code></pre><p>这里也能看出口想当的难受。而且重复代码很多。</p><h2 id="使用的依赖"><a href="#使用的依赖" class="headerlink" title="使用的依赖"></a>使用的依赖</h2><pre><code class="golang">go get github.com/facebookgo/inject</code></pre><h2 id="简单的使用例子"><a href="#简单的使用例子" class="headerlink" title="简单的使用例子"></a>简单的使用例子</h2><pre><code class="golang">type DBEngine struct {    Name string}type UserDB struct {    Db *DBEngine `inject:&quot;&quot;`}type UserService struct {    Db *UserDB `inject:&quot;&quot;`}type App struct {    Name string    User *UserService `inject:&quot;&quot;`}func (a *App) Create() string {    return &quot;create app, in db name:&quot; + a.User.Db.Db.Name + &quot; app name :&quot; + a.Name}type Object struct {    App *App}func Init() *Object {    var g inject.Graph    // 不适用依赖注入    //a := DBEngine{Name: &quot;db1&quot;}    //b := UserDB{&amp;a}    //c := UserService{&amp;b}    //app := App{Name: &quot;go-app&quot;, User: &amp;c}    app := App{Name: &quot;go-app&quot;}    _ = g.Provide(        &amp;inject.Object{Value: &amp;DBEngine{Name: &quot;db1&quot;}},        &amp;inject.Object{Value: &amp;app},    )    _ = g.Populate()    return &amp;Object{        App: &amp;app,    }}func TestMains(t *testing.T) {    obj := Init()    fmt.Println(obj.App.Create())}</code></pre><p>这样很简单就实现了golang的依赖注入，看这个开源库的源码发现，整个类库的实现才500多行代码。这是多么轻量级的一个类库，只不过代码这么短，功能也不会太多，相比laravel的依赖注入而言，它的功能就单一太多了。不过没关系，相比Guice而言这些缺失的功能不是必须的，能帮我们省掉很多代码它已经做得很好了，这就足够了。</p><p>所以最上面的代码就可以修改为：</p><pre><code class="golang">    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()</code></pre><h2 id="在gin使用依赖注入"><a href="#在gin使用依赖注入" class="headerlink" title="在gin使用依赖注入"></a>在gin使用依赖注入</h2><pre><code class="golang">func TestInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //使用 Inject New方法就不用写了    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, userController.Login)        api.POST(&quot;/register&quot;, userController.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), userController.Info)    }    _ = app.Run(&quot;:8080&quot;)}func TestNoInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //不使用 Inject    repository := repositories.NewUserRepository()    userServices := services.NewUserServices(repository)    controller := controllers.NewUserController(userServices)    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, controller.Login)        api.POST(&quot;/register&quot;, controller.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), controller.Info)    }    _ = app.Run(&quot;:8080&quot;)}</code></pre><p>源码：<a href="https://github.com/myxy99/shopping" target="_blank" rel="noopener">https://github.com/myxy99/shopping</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> inject </tag>
            
            <tag> gin </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现RabbitMQ五种模式</title>
      <link href="/posts/golang/4b90efe7.html"/>
      <url>/posts/golang/4b90efe7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 11:07:22 GMT+0800 (GMT+08:00) --><h1 id="使用的依赖包"><a href="#使用的依赖包" class="headerlink" title="使用的依赖包"></a>使用的依赖包</h1><pre><code class="golang">github.com/streadway/amqp</code></pre><h1 id="创建RabbitMQ实例"><a href="#创建RabbitMQ实例" class="headerlink" title="创建RabbitMQ实例"></a>创建RabbitMQ实例</h1><pre><code class="golang">package RabbitMQimport (    &quot;fmt&quot;    &quot;github.com/streadway/amqp&quot;    &quot;log&quot;)// 用户名 密码 ip:端口/虚拟机const MQURL = &quot;amqp://admin:123456@127.0.0.1:5672/test&quot;type RabbitMQ struct {    conn    *amqp.Connection    channel *amqp.Channel    //队列名称    QueueName string    //交换机    Exchange string    //key    key string    //连接信息    MqUrl string}//创建RabbitMQ结构体实例func NewRabbitMQ(queueName, exchange, key string) *RabbitMQ {    rabbitmq := &amp;RabbitMQ{QueueName: queueName, Exchange: exchange, key: key, MqUrl: MQURL}    var err error    //创建RabbitMQ连接    rabbitmq.conn, err = amqp.Dial(rabbitmq.MqUrl)    rabbitmq.failOnErr(err, &quot;创建连接错误!&quot;)    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;获取channel失败!&quot;)    return rabbitmq}//断开channel和connectionfunc (r *RabbitMQ) Destroy() {    r.channel.Close()    r.conn.Close()}//错误处理函数func (r *RabbitMQ) failOnErr(err error, message string) {    if err != nil {        log.Fatalf(&quot;%s:%s&quot;, message, err)        panic(fmt.Sprintf(&quot;%s,%s&quot;, message, err))    }}</code></pre><h1 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h1><p>Simple模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708092914.png" alt="Simple模式"></p><pre><code class="golang">//创建简单模式下RabbitMQ实例func NewRabbitMQSimple(queueName string) *RabbitMQ {    return NewRabbitMQ(queueName, &quot;&quot;, &quot;&quot;)}//简单模式下生产代码func (r *RabbitMQ) PublishSimple(message string) {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil,    )    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.发送消息到队列中    err = r.channel.Publish(        r.Exchange,        r.QueueName,        //如果为true,根据exchange类型和routekey规则,如果无法找到符合条件的队列那么会把发送的消息返回给发送者        false,        //如果为true,当exchange发送消息队列到队列后发现队列上没有绑定消费者,则会把消息发还给发送者        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })    if err != nil {        fmt.Println(&quot;Publish:&quot;, err)    }}//简单模式下消费代码func (r *RabbitMQ) ConsumeSimple() {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil)    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.接受消息    msgs, err := r.channel.Consume(        r.QueueName,        //用来区分多个消费者        &quot;&quot;,        //是否自动应答        true,        //是否具有排他性        false,        //如果设置为true,表示不能将同一个connection中发送消息传递给这个connection中的消费者        false,        //队列消费是否阻塞        false,        nil)    if err != nil {        fmt.Println(&quot;Consume:&quot;, err)    }    forever := make(chan bool)    //3.启用协程处理消息    go func() {        for d := range msgs {            //实现我们要处理的逻辑函数            log.Printf(&quot;Received a message:%s&quot;, d.Body)        }    }()    log.Printf(&quot;[*] Waiting for messages,To exit press CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="简单模式publish"><a href="#简单模式publish" class="headerlink" title="简单模式publish"></a>简单模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;go-rabbitmq/RabbitMQ&quot;)func main()  {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.PublishSimple(&quot;myxy99.cn msg&quot;)    fmt.Println(&quot;发送成功!&quot;)}</code></pre><h2 id="简单模式recevie"><a href="#简单模式recevie" class="headerlink" title="简单模式recevie"></a>简单模式recevie</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="Work模式"><a href="#Work模式" class="headerlink" title="Work模式"></a>Work模式</h1><p>Work模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708093050.png" alt="Work模式"></p><p>simple模式和work模式其实用的是一套逻辑代码，只是work模式是可以有多个消费者的，work模式起到一个负载均衡的作用。</p><h2 id="work模式publish"><a href="#work模式publish" class="headerlink" title="work模式publish"></a>work模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    for i := 0; i &lt;= 100; i++ {        rabbitmq.PublishSimple(&quot;Hello test!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="work模式receive1"><a href="#work模式receive1" class="headerlink" title="work模式receive1"></a>work模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h2 id="work模式receive2"><a href="#work模式receive2" class="headerlink" title="work模式receive2"></a>work模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><p>订阅模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708095831.png" alt=""></p><p>订阅模式的特别是：一个消息被投递到多个队列，一个消息能被多个消费者获取。过程是由生产者将消息发送到exchange(交换机）里，然后exchange通过一系列的规则发送到队列上，然后由绑定对应的消费者进行消息。</p><pre><code class="golang">//订阅模式创建RabbitMQ实例func NewRabbitMQPubSub(exchangeName string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,&quot;&quot;)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//订阅模式生产func (r *RabbitMQ) PublishPub(message string) {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        &quot;fanout&quot;,        true,        false,        //true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        &quot;&quot;,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//订阅模式消费端代码func (r *RabbitMQ) RecieveSub() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;fanout&quot;,        true,        false,        //YES表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        &quot;&quot;,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="订阅模式publish"><a href="#订阅模式publish" class="headerlink" title="订阅模式publish"></a>订阅模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    for i := 0; i &lt; 100; i++ {        rabbitmq.PublishPub(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        fmt.Println(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        time.Sleep(1 * time.Second)    }}</code></pre><h2 id="订阅模式receive1"><a href="#订阅模式receive1" class="headerlink" title="订阅模式receive1"></a>订阅模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h2 id="订阅模式receive2"><a href="#订阅模式receive2" class="headerlink" title="订阅模式receive2"></a>订阅模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h1 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h1><p>路由模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100024.png" alt=""></p><p>路由模式:一个消息由多个消费者消费的基础上指定由哪些消息者来消费。</p><pre><code class="golang">func NewRabbitMQRouting(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//路由模式发送消息func (r *RabbitMQ) PublishRouting(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成direct        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exchange&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//路由模式接受消息func (r *RabbitMQ) RecieveRouting() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //需要绑定key        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="路由模式publish"><a href="#路由模式publish" class="headerlink" title="路由模式publish"></a>路由模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishRouting(&quot;Hello myxy99 one!&quot; + strconv.Itoa(i))        mqTwo.PublishRouting(&quot;Hello myxy99 Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="路由模式receive-one"><a href="#路由模式receive-one" class="headerlink" title="路由模式receive-one"></a>路由模式receive-one</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mq.RecieveRouting()}</code></pre><h2 id="路由模式receive-two"><a href="#路由模式receive-two" class="headerlink" title="路由模式receive-two"></a>路由模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    mq.RecieveRouting()}</code></pre><h1 id="话题模式"><a href="#话题模式" class="headerlink" title="话题模式"></a>话题模式</h1><p>话题模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100143.png" alt=""></p><p>话题模式：话题模式是在路由模式上演化而来。不同的是我们以通配符的方式来指定我们的消费者。</p><pre><code class="golang">//话题模式//创建RabbitMQ实例func NewRabbitMQTopic(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//话题模式发送消息func (r *RabbitMQ) PublishTopic(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成topic        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//话题模式接受消息//要注意key,规则//其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）//匹配 myxy99.* 表示匹配 myxy99.hello, 但是myxy99.hello.one需要用myxy99.#才能匹配到func (r *RabbitMQ) RecieveTopic() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="话题模式publish"><a href="#话题模式publish" class="headerlink" title="话题模式publish"></a>话题模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishTopic(&quot;Hello myxy99 topic one!&quot; + strconv.Itoa(i))        mqTwo.PublishTopic(&quot;Hello myxy99 topic Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="话题模式receive-all"><a href="#话题模式receive-all" class="headerlink" title="话题模式receive-all"></a>话题模式receive-all</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;#&quot;)    mq.RecieveTopic()}</code></pre><h2 id="话题模式receive-two"><a href="#话题模式receive-two" class="headerlink" title="话题模式receive-two"></a>话题模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.*.two&quot;)    mq.RecieveTopic()}</code></pre><p>GitHub地址：<a href="https://github.com/myxy99/Go-RabbitMQ" target="_blank" rel="noopener">https://github.com/myxy99/Go-RabbitMQ</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Redis简易封装</title>
      <link href="/posts/golang/b9458491.html"/>
      <url>/posts/golang/b9458491.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 08 2020 07:06:51 GMT+0800 (GMT+08:00) --><h1 id="Golang-Redis"><a href="#Golang-Redis" class="headerlink" title="Golang Redis"></a>Golang Redis</h1><h2 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h2><pre><code class="golang">go get github.com/gomodule/redigo</code></pre><h2 id="Redis-操作封装"><a href="#Redis-操作封装" class="headerlink" title="Redis 操作封装"></a>Redis 操作封装</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="ini">[redis]Host = 127.0.0.1:6379Password =MaxIdle = 30MaxActive = 30IdleTimeout = 200</code></pre><h3 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h3><pre><code class="golang">package Redisimport (    &quot;encoding/json&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;github.com/gomodule/redigo/redis&quot;)//定义redis连接池var Conn *redis.Pool//初始化func InitRedis() error {    Conn = &amp;redis.Pool{        MaxIdle:     Config.RedisSetting.MaxIdle,        MaxActive:   Config.RedisSetting.MaxActive,        IdleTimeout: Config.RedisSetting.IdleTimeout,        Dial: func() (redis.Conn, error) {            c, err := redis.Dial(&quot;tcp&quot;, Config.RedisSetting.Host)            if err != nil {                return nil, err            }            if Config.RedisSetting.Password != &quot;&quot; {                if _, err := c.Do(&quot;AUTH&quot;, Config.RedisSetting.Password); err != nil {                    _ = c.Close()                    return nil, err                }            }            return c, err        },        TestOnBorrow: func(c redis.Conn, t time.Time) error {            _, err := c.Do(&quot;PING&quot;)            return err        },    }    return nil}//redis 设置函数func Set(key string, data interface{}, time int) (bool, error) {    conn := Conn.Get()    defer conn.Close()    value, err := json.Marshal(data)    if err != nil {        return false, err    }    reply, err := redis.String(conn.Do(&quot;SET&quot;, key, value))    _, _ = conn.Do(&quot;EXPIRE&quot;, key, time)    return reply == &quot;OK&quot;, err}//redis 检测存在函数func Exists(key string) bool {    conn := Conn.Get()    defer conn.Close()    exists, err := redis.Bool(conn.Do(&quot;EXISTS&quot;, key))    if err != nil {        return false    }    return exists}//redis 获取函数func Get(key string) ([]byte, error) {    conn := Conn.Get()    defer conn.Close()    reply, err := redis.Bytes(conn.Do(&quot;GET&quot;, key))    if err != nil {        return nil, err    }    return reply, nil}//redis 删除函数func Delete(key string) (bool, error) {    conn := Conn.Get()    defer conn.Close()    return redis.Bool(conn.Do(&quot;DEL&quot;, key))}//redis 模糊删除函数func LikeDeletes(key string) error {    conn := Conn.Get()    defer conn.Close()    keys, err := redis.Strings(conn.Do(&quot;KEYS&quot;, &quot;*&quot;+key+&quot;*&quot;))    if err != nil {        return err    }    for _, key := range keys {        _, err = Delete(key)        if err != nil {            return err        }    }    return nil}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="golang">if err := Redis.InitRedis(); err != nil {    log.Println(&quot;init redis failed, err:&quot; + err.Error())    return}</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code class="golang">...if Redis.Exists(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...if Redis.Get(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...</code></pre><p>使用很简单这里就不一一举例了。通过这样的封装redis操作就变得更加简单了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang使用jwt</title>
      <link href="/posts/golang/631d0e90.html"/>
      <url>/posts/golang/631d0e90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 08 2020 07:06:51 GMT+0800 (GMT+08:00) --><h1 id="Golang中使用JWT-json-web-token"><a href="#Golang中使用JWT-json-web-token" class="headerlink" title="Golang中使用JWT(json web token)"></a>Golang中使用JWT(json web token)</h1><h2 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h2><p>什么是jwt这里就不多说了，官网有介绍。官网介绍：<a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h3><pre><code class="golang">go get -u github.com/dgrijalva/jwt-go</code></pre><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="ini">[jwt]# 盐JwtSecret = jdnsakjbduiiudu# 过期时间（天ExpiresAt = 3# 签发Issuer = jwt</code></pre><h4 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h4><pre><code class="golang">package Utilsimport (    &quot;errors&quot;    &quot;github.com/dgrijalva/jwt-go&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;wPan/v1/Models&quot; //加载模型)// JWT 签名结构type JWT struct {    SigningKey []byte}//JWT 中存储得数据结构体 这里可以根据需求自由添加type UserInfo struct {    Id       int    `json:&quot;id&quot;`    Username string `json:&quot;username&quot;`    Email    string `json:&quot;email&quot;`    Status   int    `json:&quot;status&quot;`}// 生成JWT函数func GenerateToken(user *Models.User) (string, error) {    claim := jwt.MapClaims{        //这里为自定义        &quot;username&quot;: user.UserName,        &quot;id&quot;:       user.ID,        &quot;email&quot;:    user.Email,        &quot;status&quot;:   user.Status,        //到这里，后面都是必须的        &quot;nbf&quot;: time.Now().Unix(),        &quot;iat&quot;: time.Now().Unix(),        //设置过期时间        &quot;exp&quot;: time.Now().Unix() + Config.JWTSetting.ExpiresAt*60*60,        //签名方        &quot;iss&quot;: Config.JWTSetting.Issuer,    }    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)    tokens, err := token.SignedString([]byte(Config.JWTSetting.JwtSecret))    return tokens, err}//设置盐func secret() jwt.Keyfunc {    return func(token *jwt.Token) (interface{}, error) {        return []byte(Config.JWTSetting.JwtSecret), nil    }}//token 验证func ParseToken(tokens string) (user *UserInfo, err error) {    user = &amp;UserInfo{}    token, err := jwt.Parse(tokens, secret())    if err != nil {        return    }    claim, ok := token.Claims.(jwt.MapClaims)    if !ok {        err = errors.New(&quot;cannot convert claim to mapclaim&quot;)        return    }    //验证token，如果token被修改过则为false    if !token.Valid {        err = errors.New(&quot;token is invalid&quot;)        return    }    //提取当初我们生成时候存储的数据    user.Id = int(claim[&quot;id&quot;].(float64))    user.Username = claim[&quot;username&quot;].(string)    user.Email = claim[&quot;email&quot;].(string)    user.Status = int(claim[&quot;status&quot;].(float64))    return}</code></pre><p>Service中的使用</p><pre><code class="golang">func GetJwt(u *Models.User) (string, bool) {    token, err := Utils.GenerateToken(u)    if err != nil {        return &quot;&quot;, false    }    return token, true}</code></pre><h4 id="编写验证中间件"><a href="#编写验证中间件" class="headerlink" title="编写验证中间件"></a>编写验证中间件</h4><p>我这里使用的gin框架，其他的框架也类似</p><pre><code class="golang">func Auth() gin.HandlerFunc {    return func(c *gin.Context) {        token := c.GetHeader(&quot;Authorization&quot;)        userInfo, err := Utils.ParseToken(token[7:])        if err != nil {            R.Response(c, http.StatusUnauthorized, R.AUTH_ERROR, nil, http.StatusUnauthorized)            c.Abort()            return        }        c.Set(&quot;userInfo&quot;, userInfo)        c.Next()        return    }}</code></pre><h4 id="路由中使用"><a href="#路由中使用" class="headerlink" title="路由中使用"></a>路由中使用</h4><pre><code class="golang">authApi.GET(&quot;/info&quot;, Middleware.Auth(), Controllers.Info)</code></pre><p>这样用户再访问需要验证的请求时，就需要请求头中带上<code>Authorization</code>，value为token。</p><p>参考连接：<a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">https://github.com/dgrijalva/jwt-go</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang邮件发送</title>
      <link href="/posts/golang/4db013d1.html"/>
      <url>/posts/golang/4db013d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><pre><code class="golang">go get github.com/jordan-wright/email</code></pre><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;net/smtp&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    e := email.NewEmail()    //设置发送方的邮箱    e.From = &quot;112233 &lt;XXX@qq.com&gt;&quot;    // 设置接收方的邮箱    e.To = []string{&quot;XXX@qq.com&quot;}    //设置主题    e.Subject = &quot;这是主题&quot;    //设置文件发送的内容    e.Text = []byte(&quot;发送的内容&quot;)    //设置服务器相关的配置    err := e.Send(&quot;smtp.qq.com:25&quot;, smtp.PlainAuth(&quot;&quot;, &quot;你的邮箱账号&quot;, &quot;这块是你的授权码&quot;, &quot;smtp.qq.com&quot;))    if err != nil {       ....    }}</code></pre><h2 id="实现抄送功能"><a href="#实现抄送功能" class="headerlink" title="实现抄送功能"></a>实现抄送功能</h2><pre><code class="golang">func main() {    ...    //设置抄送如果抄送多人逗号隔开    e.Cc = []string{&quot;XXX@qq.com&quot;,XXX@qq.com}    //设置秘密抄送    e.Bcc = []string{&quot;XXX@qq.com&quot;}    ...}</code></pre><h2 id="发送html代码的邮件"><a href="#发送html代码的邮件" class="headerlink" title="发送html代码的邮件"></a>发送html代码的邮件</h2><pre><code class="golang">func main() {    ...    e.HTML = []byte(`    &lt;h1&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/h1&gt;        `)    ...}</code></pre><h2 id="实现邮件附件的发送"><a href="#实现邮件附件的发送" class="headerlink" title="实现邮件附件的发送"></a>实现邮件附件的发送</h2><pre><code class="golang">func main() {    ...    e.AttachFile(&quot;./test.txt&quot;)    ...}</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>每次调用Send时都会和 SMTP 服务器建立一次连接，如果发送邮件很多很频繁的话可能会有性能问题。email提供了连接池，可以复用网络连接：</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net/smtp&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    ch := make(chan *email.Email, 10)    p, err := email.NewPool(        &quot;smtp.qq.com:25&quot;,        4,        smtp.PlainAuth(&quot;&quot;, &quot;XXX@qq.com&quot;, &quot;你的授权码&quot;, &quot;smtp.qq.com&quot;),    )    if err != nil {        log.Fatal(&quot;failed to create pool:&quot;, err)    }    var wg sync.WaitGroup    wg.Add(4)    for i := 0; i &lt; 4; i++ {        go func() {            defer wg.Done()            for e := range ch {                err := p.Send(e, 10*time.Second)                if err != nil {                    fmt.Fprintf(os.Stderr, &quot;email:%v sent error:%v\n&quot;, e, err)                }            }        }()    }    for i := 0; i &lt; 10; i++ {        e := email.NewEmail()        e.From = &quot;dj &lt;XXX@qq.com&gt;&quot;        e.To = []string{&quot;XXX@qq.com&quot;}        e.Subject = &quot;Awesome web&quot;        e.Text = []byte(fmt.Sprintf(&quot;Awesome Web %d&quot;, i+1))        ch &lt;- e    }    close(ch)    wg.Wait()}</code></pre><p>上面程序中，我们创建 4 goroutine 共用一个连接池发送邮件，发送 10 封邮件后程序退出。为了等邮件都发送完成或失败，程序才退出，我们使用了sync.WaitGroup。由于使用了 goroutine，邮件顺序不能保证。</p><p>参考连接：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/posts/jenkins/87b776c7.html"/>
      <url>/posts/jenkins/87b776c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json   #这个Json文件与上边的配置文件是相同的</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出 </p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/posts/golang/41aae1e1.html"/>
      <url>/posts/golang/41aae1e1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 21:25:44 GMT+0800 (GMT+08:00) --><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre><p>参考连接：<a href="https://www.cnblogs.com/blogbobo/p/13169714.html" target="_blank" rel="noopener">https://www.cnblogs.com/blogbobo/p/13169714.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
