<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang实现将Hexo博客文章推送到微信公众号</title>
      <link href="/posts/golang/43d25c0d.html"/>
      <url>/posts/golang/43d25c0d.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="Golang实现将Hexo博客文章推送到微信公众号"><a href="#Golang实现将Hexo博客文章推送到微信公众号" class="headerlink" title="Golang实现将Hexo博客文章推送到微信公众号"></a>Golang实现将Hexo博客文章推送到微信公众号</h1><p>最近在写博客的时候，就在想，能不能实现博客更新了然后就自动给别人提醒呢？比如每天提醒更新了什么博客。然后就有了这个项目，我的想法就是通过golang进行爬虫，把所有的文章都存储起来，获取到新的文章，然后把新的文章连接进行整合，发送到微信公众号，这样所有的关注了微信公众号的，就能收到，每天更新的新的博客。</p><h1 id="实现爬虫"><a href="#实现爬虫" class="headerlink" title="实现爬虫"></a>实现爬虫</h1><p>这里我选择的是colly爬虫框架。然后把爬取的数据进行数据库存储。</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;github.com/gocolly/colly&quot;    &quot;regexp&quot;    &quot;strings&quot;    &quot;wx-blog/config&quot;    Redis &quot;wx-blog/redis&quot;    &quot;wx-blog/utils&quot;)func main() {    i := config.Config{}    conf := i.GetConf()    redis := Redis.NewRedis(conf)    //爬虫采集 收集到redis    //获取需要爬取的地址    webList := redis.HGetAll(&quot;BlogUrl&quot;).Val()    for key, value := range webList {        c := colly.NewCollector(            colly.AllowedDomains(strings.Split(key, &quot;//&quot;)[1]),        )        c.OnRequest(func(request *colly.Request) {            //去重            ok, _ := redis.HExists(&quot;BlogUrl&quot;, utils.GetMd5(request.URL.String())).Result()            if ok {                request.Abort()                return            }            fmt.Println(request.URL.String())        })        c.OnHTML(&quot;a[href]&quot;, func(e *colly.HTMLElement) {            //获取所有a            _ = e.Request.Visit(e.Attr(&quot;href&quot;))        })        c.OnHTML(&quot;title&quot;, func(e *colly.HTMLElement) {            //文章页面正则提取            matched, _ := regexp.MatchString(value, e.Request.URL.String())            if matched {                //最新的连接存储到redis                redis.HSet(&quot;BlogUrl_req&quot;, e.Text, e.Request.URL.String())                //去记录重库                redis.HSet(&quot;BlogUrl_db&quot;, utils.GetMd5(e.Request.URL.String()), e.Text)            }        })        _ = c.Visit(key)    }}</code></pre><p><em>爬虫前需要把需要爬虫的网站信息存储到redis中</em></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/15/20200715123711.png" alt=""></p><p>爬取结果：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/15/20200715123621.png" alt=""></p><h1 id="实现微信公众号数据的发送"><a href="#实现微信公众号数据的发送" class="headerlink" title="实现微信公众号数据的发送"></a>实现微信公众号数据的发送</h1><p>微信发送使用的群发接口，需要服务号认证才行。这里使用的是测试账号。</p><p>weix.go</p><pre><code class="golang">package weiximport (    &quot;encoding/json&quot;    &quot;errors&quot;    &quot;fmt&quot;    &quot;wx-blog/request&quot;)const (    WxGetAccessToken = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=%v&amp;secret=%v&quot;    WxSendText       = &quot;https://api.weixin.qq.com/cgi-bin/message/mass/sendall?access_token=%v&quot;)type WeiX struct {    AppID       string    AppSecret   string    AccessToken string}//获取token方法func (w *WeiX) GetToken() (err error) {    url := fmt.Sprintf(WxGetAccessToken, w.AppID, w.AppSecret)    i := &amp;request.Request{}    i.Call(&quot;GET&quot;, url, nil)    if i.Err == nil {        var data map[string]interface{}        err = json.Unmarshal(i.Body, &amp;data)        if err == nil {            a := data[&quot;access_token&quot;]            if a != nil {                w.AccessToken = data[&quot;access_token&quot;].(string)                return            }            err = errors.New(&quot;请检查AppID，AppSecret&quot;)            return        }    }    return}//发送信息方法func (w *WeiX) Send(message string) (err error) {    url := fmt.Sprintf(WxSendText, w.AccessToken)    i := &amp;request.Request{}    i.Call(&quot;POST&quot;, url, []byte(message))    if i.Err == nil {        var data map[string]interface{}        err = json.Unmarshal(i.Body, &amp;data)        if err == nil {            fmt.Println(data)        }    }    return}</code></pre><p>wx.go</p><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;wx-blog/config&quot;    Redis &quot;wx-blog/redis&quot;    &quot;wx-blog/weix&quot;)func main() {    i := config.Config{}    conf := i.GetConf()    redis := Redis.NewRedis(conf)    //获取最新的文章：    data, err := redis.HGetAll(&quot;BlogUrl_req&quot;).Result()    if err != nil {        log.Panic(err.Error())    }    if data == nil {        log.Panic(&quot;没有新文章&quot;)        return    }    //封装发送的数据    var message string    for key, value := range data {        message += key + &quot;:&quot; + value + &quot;&lt;br&gt;&quot;    }    //初始化微信    wx := weix.WeiX{        AppSecret: conf.WX.AppSecret,        AppID:     conf.WX.AppID,    }    //获取Token    err = wx.GetToken()    if err != nil {        log.Panic(err.Error())    }    //封装消息    sendMessage := `{   &quot;filter&quot;:{      &quot;is_to_all&quot;:false,      &quot;tag_id&quot;:100   },   &quot;text&quot;:{      &quot;content&quot;:` + message + `   },    &quot;msgtype&quot;:&quot;text&quot;}`    //发送消息    err = wx.Send(sendMessage)    if err != nil {        log.Panic(err.Error())    }    //待发数据    redis.HDel(&quot;BlogUrl_req&quot;)    log.Println(&quot;文章发送成功!&quot;)}</code></pre><p>参考连接:<a href="https://github.com/gocolly/colly" target="_blank" rel="noopener">https://github.com/gocolly/colly</a></p><p>源码地址:<a href="https://github.com/myxy99/weixin-blog" target="_blank" rel="noopener">https://github.com/myxy99/weixin-blog</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang遇上NSQ消息队列</title>
      <link href="/posts/golang/73e61957.html"/>
      <url>/posts/golang/73e61957.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Jul 14 2020 22:42:04 GMT+0800 (GMT+08:00) --><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>NSQ是一个基于Go语言的分布式实时消息平台, 它具有分布式、去中心化的拓扑结构，支持无限水平扩展。无单点故障、故障容错、高可用性以及能够保证消息的可靠传递的特征。另外，NSQ非常容易配置和部署, 且支持众多的消息协议。支持多种客户端，协议简单。</p><h1 id="NSQ的几个组件"><a href="#NSQ的几个组件" class="headerlink" title="NSQ的几个组件"></a>NSQ的几个组件</h1><ul><li>nsqd：一个负责接收、排队、转发消息到客户端的守护进程</li><li>nsqlookupd：管理拓扑信息, 用于收集nsqd上报的topic和channel,并提供最终一致性的发现服务的守护进程</li><li>nsqadmin：一套Web用户界面，可实时查看集群的统计数据和执行相应的管理任务</li></ul><h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h2 id="搭建主NSQ服务"><a href="#搭建主NSQ服务" class="headerlink" title="搭建主NSQ服务"></a>搭建主NSQ服务</h2><h3 id="获取到自己的服务器ip"><a href="#获取到自己的服务器ip" class="headerlink" title="获取到自己的服务器ip"></a>获取到自己的服务器ip</h3><p>我这里就是我服务器的外网ip<br><code>39.106.33.33</code></p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><pre><code class="docker">docker pull nsqio/nsq  #拉取nsq镜像docker images          #查看nsq镜像</code></pre><h3 id="启动nsqlookupd服务"><a href="#启动nsqlookupd服务" class="headerlink" title="启动nsqlookupd服务"></a>启动nsqlookupd服务</h3><p>这个服务就是监控所有的nsq节点服务，这里开了两个端口4160和4161，4160就是来给节点访问的，4161是为了nsqadmin使用</p><pre><code class="docker">docker run -d --name lookupd -p 4160:4160 -p 4161:4161 nsqio/nsq:latest /nsqlookupddocker exec -ti lookupd /bin/sh    #进入容器，查看nsq目录结构</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/14/20200714221747.png" alt=""></p><h3 id="启动nsqadmin管理系统"><a href="#启动nsqadmin管理系统" class="headerlink" title="启动nsqadmin管理系统"></a>启动nsqadmin管理系统</h3><pre><code class="docker">docker run -d --name nsqadmin     -p 4171:4171 nsqio/nsq /nsqadmin     --lookupd-http-address=第一步获取的服务器ip:4161</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/14/20200714221844.png" alt=""></p><h2 id="部署NSQd节点服务"><a href="#部署NSQd节点服务" class="headerlink" title="部署NSQd节点服务"></a>部署NSQd节点服务</h2><h3 id="在主服务器上开启一个nsqd节点服务"><a href="#在主服务器上开启一个nsqd节点服务" class="headerlink" title="在主服务器上开启一个nsqd节点服务"></a>在主服务器上开启一个nsqd节点服务</h3><pre><code class="docker">docker run -d --name nsqd -p 4150:4150 -p   4151:4151 nsqio/nsq:latest /nsqd   --broadcast-address=当前服务器ip   --lookupd-tcp-address=第一步获取的服务器ip:4160</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/14/20200714221947.png" alt=""></p><h3 id="创建从服务器（可以省略，根据需求来）"><a href="#创建从服务器（可以省略，根据需求来）" class="headerlink" title="创建从服务器（可以省略，根据需求来）"></a>创建从服务器（可以省略，根据需求来）</h3><p>启动一个nsqd服务</p><pre><code class="docker">docker run -d --name nsqd -p 4150:4150 -p     4151:4151 nsqio/nsq:latest     /nsqd     --broadcast-address=当前服务器ip     --lookupd-tcp-address=主服务器ip:4160</code></pre><h2 id="进入后台"><a href="#进入后台" class="headerlink" title="进入后台"></a>进入后台</h2><p>访问：ip:4171</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/14/20200714222423.png" alt=""></p><p>搭建成功</p><h1 id="Golang操作使用nsq"><a href="#Golang操作使用nsq" class="headerlink" title="Golang操作使用nsq"></a>Golang操作使用nsq</h1><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><pre><code class="golang">&quot;github.com/nsqio/go-nsq&quot;</code></pre><h2 id="服务端-消费者"><a href="#服务端-消费者" class="headerlink" title="服务端(消费者)"></a>服务端(消费者)</h2><pre><code class="golang">package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;github.com/nsqio/go-nsq&quot;    &quot;sync&quot;    &quot;time&quot;)var (tcpNsqdAddrr = &quot;xxx.xxx.xxx.xxx:4150&quot;)//声明一个结构体，实现HandleMessage接口方法（根据文档的要求）type NsqHandler struct{}//实现HandleMessage方法//message是接收到的消息func (s *NsqHandler) HandleMessage(message *nsq.Message) error {    //打印消息的一些基本信息    fmt.Printf(&quot;msg.Timestamp=&quot;+        &quot;%v, msg.nsqaddress=&quot;+        &quot;%s,msg.body=&quot;+        &quot;%s \n&quot;,        time.Unix(0, message.Timestamp).Format(&quot;2006-01-02 03:04:05&quot;),        message.NSQDAddress,        string(message.Body))    //解析传递的json数据    var mapData map[string]interface{}    _ = json.Unmarshal(message.Body, &amp;mapData)    //具体的业务逻辑    return nil}func main() {    //初始化配置    config := nsq.NewConfig()    //创造消费者，参数一时订阅的主题，参数二是使用的通道    com, err := nsq.NewConsumer(&quot;wpan&quot;, &quot;email&quot;, config)    if err != nil {        fmt.Println(err)    }    //添加处理回调    com.AddHandler(&amp;NsqHandler{})    //连接对应的nsqd    err = com.ConnectToNSQD(tcpNsqdAddrr)    if err != nil {        fmt.Println(err)    }    //只是为了不结束此进程，这里没有意义    var wg = &amp;sync.WaitGroup{}    wg.Add(1)    wg.Wait()}</code></pre><h2 id="客户端-生产者"><a href="#客户端-生产者" class="headerlink" title="客户端(生产者)"></a>客户端(生产者)</h2><pre><code class="golang">package mainimport (    &quot;encoding/json&quot;    &quot;fmt&quot;    &quot;github.com/nsqio/go-nsq&quot;)var (    //nsqd的地址，使用了tcp监听的端口    tcpNsqdAddrr = &quot;xxx.xxx.xxx.xxx:4150&quot;)func main() {    //初始化配置    config := nsq.NewConfig()    for i := 0; i &lt; 100; i++ {        //创建100个生产者        tPro, err := nsq.NewProducer(tcpNsqdAddrr, config)        if err != nil {            fmt.Println(&quot;创建生产者&quot;, err)        }        //主题        topic := &quot;Insert&quot;    //主题内容    //封装发送数据        Command := make(map[string]interface{})        data, err := json.Marshal(Command)        //发布消息        err = tPro.Publish(topic, []byte(data))        if err != nil {            fmt.Println(&quot;发布消息&quot;, err)        }    }}</code></pre><p>参考连接：<a href="https://nsq.io/overview/quick_start.html" target="_blank" rel="noopener">https://nsq.io/overview/quick_start.html</a></p><p>参考连接：<a href="https://github.com/nsqio/go-nsq" target="_blank" rel="noopener">https://github.com/nsqio/go-nsq</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> nsq </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gin表单绑定验证器</title>
      <link href="/posts/golang/45b8b2b1.html"/>
      <url>/posts/golang/45b8b2b1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Mon Jul 13 2020 12:56:08 GMT+0800 (GMT+08:00) --><h1 id="gin中内置validator的基础使用"><a href="#gin中内置validator的基础使用" class="headerlink" title="gin中内置validator的基础使用"></a>gin中内置validator的基础使用</h1><pre><code class="golang">type UserLoginParam struct {    Name     string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required,min=2,max=30&quot;`    Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required,min=8,max=40&quot;`}func TestValidator(t *testing.T) {    app := gin.New()    app.POST(&quot;/login&quot;, func(context *gin.Context) {        var userLoginService UserLoginParam        err := context.ShouldBind(&amp;userLoginService)        if err != nil {            context.JSON(http.StatusUnprocessableEntity, gin.H{                &quot;msg&quot;: err.Error(),            })        }else{            context.JSON(http.StatusOK, gin.H{                &quot;msg&quot;: &quot;通过验证&quot;,            })        }        return    })    _ = app.Run(&quot;:8888&quot;)}</code></pre><p>我们使用postman请求测试下：</p><p>拒绝：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713084519.png" alt=""></p><p>通过：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713084911.png" alt=""></p><p>可以看到表单验证已经生效，但是错误提示的字段不是特别友好，我们首先需要整理成前端能够解析的样子，在考虑翻译的问题。</p><h1 id="优化返回格式"><a href="#优化返回格式" class="headerlink" title="优化返回格式"></a>优化返回格式</h1><p>我们这里可以看到所有的验证输出都是来之或者ShouldBind后的err，我们就先看看这个err在哪里定义的，这里可以通过fmt包查看他的类型，就知道他定义的位置。</p><pre><code class="golang">fmt.Printf(&quot;%T \n&quot;, err)</code></pre><p>这里发现他的类型为:</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713085854.png" alt=""></p><p>下一步就是找到他的定义了。然后发现他是一个FieldError切片类型：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713090619.png" alt=""></p><p>然后我们继续看看FieldError是个什么东西：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713090827.png" alt=""></p><p>发现这里的FieldError是一个接口类型，里面的接口想必就是获取各种信息的。我们打印一下看看，所有我们需要改一下我们的代码，这里我就随便打印几个，其实我们看下官方在接口定义哪里的注释，也大概能明白什么意思。</p><pre><code class="golang">        if err != nil {            fmt.Printf(&quot;%T \n&quot;, err)            errors := err.(validator.ValidationErrors)            for _, value := range errors {                fmt.Println(value.Kind())                fmt.Println(value.Field())                fmt.Println(value.ActualTag())            }            context.JSON(http.StatusUnprocessableEntity, gin.H{                &quot;msg&quot;: err.Error(),            })        } else {            context.JSON(http.StatusOK, gin.H{                &quot;msg&quot;: &quot;通过验证&quot;,            })        }</code></pre><p>访问接口=&gt;输出</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713091434.png" alt=""></p><p>这里也就很明显了。我们现在就能拿到我们错误信息进行封装返回了。我们小改一下代码：</p><pre><code class="golang">func getParamError(err validator.ValidationErrors) map[string]string {    result := make(map[string]string, 0)    for _, v := range err {        result[v.Field()] = v.Tag()    }    return result}func TestValidator(t *testing.T) {    app := gin.Default()    app.POST(&quot;/login&quot;, func(context *gin.Context) {        var userLoginService UserLoginParam        err := context.ShouldBind(&amp;userLoginService)        if err != nil {            fmt.Printf(&quot;%T \n&quot;, err)            errors := err.(validator.ValidationErrors)            context.JSON(http.StatusUnprocessableEntity, gin.H{                &quot;msg&quot;: getParamError(errors),            })        } else {            context.JSON(http.StatusOK, gin.H{                &quot;msg&quot;: &quot;通过验证&quot;,            })        }        return    })    _ = app.Run(&quot;:8888&quot;)}</code></pre><p>现在访问一下再看看：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713092201.png" alt=""></p><p>但是这样对于前端，还是不好获取，所有我把他改为数组。前端只需要循环这个数组就行。</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/13/20200713101702.png" alt=""></p><h1 id="自定义字段校验方法"><a href="#自定义字段校验方法" class="headerlink" title="自定义字段校验方法"></a>自定义字段校验方法</h1><pre><code class="golang">type UserLoginParam struct {    Name     string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required,min=2,max=30,bookableDate&quot;`    Password string `form:&quot;password&quot; json:&quot;password&quot; binding:&quot;required,min=8,max=40&quot;`}func getParamError(err validator.ValidationErrors) []string {    result := make([]string, 0)    for _, v := range err {        result = append(result, fmt.Sprintf(&quot;%v错误：%v&quot;, v.Field(), v.Tag()))    }    return result}// customFunc 自定义字段级别校验方法var bookableDate validator.Func = func(fl validator.FieldLevel) bool {    date, ok := fl.Field().Interface().(time.Time)    if ok {        today := time.Now()        if today.After(date) {            return false        }    }    return true}func TestValidator(t *testing.T) {    if v, ok := binding.Validator.Engine().(*validator.Validate); ok {        //注册        _ = v.RegisterValidation(&quot;bookableDate&quot;, bookableDate)    }    app := gin.Default()    app.POST(&quot;/login&quot;, func(context *gin.Context) {        var userLoginService UserLoginParam        err := context.ShouldBind(&amp;userLoginService)        if err != nil {            errors := err.(validator.ValidationErrors)            context.JSON(http.StatusUnprocessableEntity, gin.H{                &quot;msg&quot;: getParamError(errors),            })        } else {            context.JSON(http.StatusOK, gin.H{                &quot;msg&quot;: &quot;通过验证&quot;,            })        }        return    })    _ = app.Run(&quot;:8888&quot;)}</code></pre><p>参考连接：<a href="https://gin-gonic.com/zh-cn/docs/examples/custom-validators/" target="_blank" rel="noopener">https://gin-gonic.com/zh-cn/docs/examples/custom-validators/</a></p><p>参考连接：<a href="https://github.com/go-playground/validator/" target="_blank" rel="noopener">https://github.com/go-playground/validator/</a></p><p>参考连接：<a href="https://www.liwenzhou.com/posts/Go/validator_usages/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/validator_usages/</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protobuf通信协议</title>
      <link href="/posts/golang/ac0a6a86.html"/>
      <url>/posts/golang/ac0a6a86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 20:39:53 GMT+0800 (GMT+08:00) --><h1 id="RPC的调用过程"><a href="#RPC的调用过程" class="headerlink" title="RPC的调用过程"></a>RPC的调用过程</h1><p>一个正常的RPC过程可以分为一下几个步骤：</p><ul><li>client调用client stub，这是一次本地过程调用。</li><li>client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。</li><li>client所在的系统将消息发送给server。</li><li>server的的系统将收到的包传给server stub。</li><li>server stub解包得到参数。 解包也被称作 unmarshalling。</li><li>server stub调用服务过程。返回结果按照相反的步骤传给client。</li></ul><p>在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</p><ul><li>1、Call ID映射。远端进程中间可以包含定义的多个函数，本地客户端该如何告知远端进程程序调用特定的某个函数呢？因此，在RPC调用过程中，所有的函数都需要有一个自己的ID。开发者在客户端（调用端）和服务端（被调用端）分别维护一个{函数&lt;–&gt;Call ID}的对应表。两者的表不一定完全相同，但是相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，调用者通过映射表查询想要调用的函数的名称，找到对应的Call ID，然后传递给服务端，服务端也通过查表，来确定客户端所需要调用的函数，然后执行相应函数的代码。</li><li>2、序列化与反序列化。客户端如何把参数传递给远程调用的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li>3、网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传递给服务端，然后在把序列化后的调用结果传回给客户端，完成这种数据传递功能的被成为传输层。大部分的网络传输成都使用TCP协议，属于长连接。</li></ul><p>有对传递的数据进行序列化和反序列化的操作，这就是我们这里要说的：Protobuf。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Google Protocol Buffer( 简称 Protobuf)是Google公司内部的混合语言数据标准，他们主要用于RPC系统和持续数据存储系统。</p><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。简单来说，Protobuf的功能类似于XML，即负责把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议等使用场景。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装protobuf编译器"><a href="#安装protobuf编译器" class="headerlink" title="安装protobuf编译器"></a>安装protobuf编译器</h2><p>可以在如下地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a>选择适合自己系统的Proto编译器程序进行下载并解压。然后配置环境变量：将protocke执行文件所在目录添加到当前系统的环境变量中。windows系统下可以直接在Path目录中进行添加。</p><h2 id="安装go依赖"><a href="#安装go依赖" class="headerlink" title="安装go依赖"></a>安装go依赖</h2><pre><code class="golang">go get github.com/golang/protobuf/protoc-gen-go</code></pre><h1 id="Protobuf-协议语法"><a href="#Protobuf-协议语法" class="headerlink" title="Protobuf 协议语法"></a>Protobuf 协议语法</h1><h2 id="message："><a href="#message：" class="headerlink" title="message："></a>message：</h2><p>Protobuf中定义一个数据结构需要用到关键字message，这一点和Java的class，Go语言中的struct类似。</p><h2 id="标识号："><a href="#标识号：" class="headerlink" title="标识号："></a>标识号：</h2><p>在消息的定义中，每个字段等号后面都有唯一的标识号，用于在反序列化过程中识别各个字段的，一旦开始使用就不能改变。标识号从整数1开始，依次递增，每次增加1，标识号的范围为1~2^29 – 1，其中[19000-19999]为Protobuf协议预留字段，开发者不建议使用该范围的标识号；一旦使用，在编译时Protoc编译器会报出警告。</p><h2 id="字段规则："><a href="#字段规则：" class="headerlink" title="字段规则："></a>字段规则：</h2><p>字段规则有三种：</p><ul><li>1.required：该规则规定，消息体中该字段的值是必须要设置的。</li><li>2.optional：消息体中该规则的字段的值可以存在，也可以为空，optional的字段可以根据defalut设置默认值。</li><li>3.repeated：消息体中该规则字段可以存在多个（包括0个），该规则对应java的数组或者go语言的slice。</li></ul><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><p>常见的数据类型与protoc协议中的数据类型映射如下：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712161553.png" alt=""></p><h2 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h2><p>proto协议支持使用枚举类型</p><pre><code class="golang">enum Sex{    male=1;    female=2;}</code></pre><h2 id="字段默认值："><a href="#字段默认值：" class="headerlink" title="字段默认值："></a>字段默认值：</h2><pre><code class="golang">message Address {    required sint32 id = 1 [default = 1];    required string name = 2 [default = &#39;北京&#39;];    optional string pinyin = 3 [default = &#39;beijing&#39;];    required string address = 4;    required bool flag = 5 [default = true];}</code></pre><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>如果需要引用的message是写在别的.proto文件中，可以通过import “xxx.proto”来进行引入</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><pre><code class="golang">syntax = &quot;proto3&quot;;package example;message Person {    required string Name = 1;    required int32 Age = 2;    required string From = 3;    optional Address Addr = 4;    message Address {        required sint32 id = 1;        required string name = 2;        optional string pinyin = 3;        required string address = 4;    }}</code></pre><h1 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h1><p>这里看你，需要使用什么语言的，如果你需要再c和py之间传输数据，你就需要生成对应的c和py文件，就行。这里我因为使用的golang。我就生成go的</p><pre><code class="golang">protoc --go_out=. *.proto</code></pre><h2 id="这里推荐下几个插件（golang）"><a href="#这里推荐下几个插件（golang）" class="headerlink" title="这里推荐下几个插件（golang）"></a>这里推荐下几个插件（golang）</h2><ul><li><p>protoc-gen-gogo：和protoc-gen-go生成的文件差不多，性能也几乎一样(稍微快一点点)</p></li><li><p>protoc-gen-gofast：生成的文件更复杂，性能也更高(快5-7倍)</p></li></ul><pre><code class="golang">//gogogo get github.com/gogo/protobuf/protoc-gen-gogo//gofastgo get github.com/gogo/protobuf/protoc-gen-gofast</code></pre><p>安装gogoprotobuf库文件</p><pre><code class="golang">go get github.com/gogo/protobuf/protogo get github.com/gogo/protobuf/gogoproto  //这个不装也没关系</code></pre><p>生成文件</p><pre><code class="golang">//gogoprotoc --gogo_out=. *.proto//gofastprotoc --gofast_out=. *.proto</code></pre><p>性能测试</p><pre><code class="golang">//goprotobuf&quot;编码&quot;：447ns/op&quot;解码&quot;：422ns/op//gogoprotobuf-go&quot;编码&quot;：433ns/op&quot;解码&quot;：427ns/op//gogoprotobuf-fast&quot;编码&quot;：112ns/op&quot;解码&quot;：112ns/op</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>把消息进行编码</p><pre><code class="golang">book := &amp;pb.AddressBook{}// ...out, err := proto.Marshal(book)if err != nil {        log.Fatalln(&quot;Failed to encode address book:&quot;, err)}if err := ioutil.WriteFile(fname, out, 0644); err != nil {        log.Fatalln(&quot;Failed to write address book:&quot;, err)}</code></pre><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>把消息进行解码</p><pre><code class="golang">in, err := ioutil.ReadFile(fname)if err != nil {        log.Fatalln(&quot;Error reading file:&quot;, err)}book := &amp;pb.AddressBook{}if err := proto.Unmarshal(in, book); err != nil {        log.Fatalln(&quot;Failed to parse address book:&quot;, err)}</code></pre><p>参考连接：<a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang开发分布式电商网站高并发秒杀系统</title>
      <link href="/posts/golang/6edb5861.html"/>
      <url>/posts/golang/6edb5861.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><blockquote><p>这个系统的主要目的在于秒杀，所有其他地方都做的很简单。基础功能不多！</p></blockquote><h1 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h1><blockquote><p>web框架：gin</p></blockquote><blockquote><p>消息队列：RabbitMQ</p></blockquote><blockquote><p>分布式方案：hash环</p></blockquote><blockquote><p>orm: gorm</p></blockquote><blockquote><p>限流器：tollbooth</p></blockquote><blockquote><p>登录验证：jwt</p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h1><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712131203.png" alt=""></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>cd /cmd</p><p>go run main.go //启动后台管理接口</p><p>go run client.go //启动RabbitMQ写入数据库客户端</p><p>go run spike.go //启动秒杀系统，支持横行扩展</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试没有使用集群，只是一个服务器</p><p>这里我使用测试工具是jmeter</p><h2 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090309.png" alt=""></p><h2 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712085943.png" alt=""></p><h2 id="RabbitMQ："><a href="#RabbitMQ：" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090446.png" alt=""></p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql:"></a>mysql:</h2><p>并没有超卖，测试添加了1000个库存</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090604.png" alt=""></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090629.png" alt=""></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里主要说下最重要的秒杀流程。主要的核心逻辑在<code>spike_service.go</code>中。</p><p>项目在启动的时候，我们查询一下数据库，对数据库中需要秒杀的商品的信息，缓存到程序中，再后面的秒杀请求中，对其缓存进行修改，这样就实现了去redis实现。</p><p>具体的代码：</p><pre><code class="golang">    //记录现在的秒杀商品的数量    commodityCache map[int]*models.Commodity    models.Init()    models.MysqlHandler.AutoMigrate(models.Order{})    repository := &amp;repositories.CommodityRepository{Db: models.MysqlHandler}    service := &amp;services.CommodityService{CommodityRepository: repository}    commodityList, err := service.GetCommodityAll()      for _, value := range *commodityList {        commodityCache[int(value.ID)] = &amp;value  }</code></pre><p>这样缓存到了程序中，后面的判断都再这个程序缓存中，速度就快很多。但是这也有个缺点，当你的秒杀商品很多的时候，可能导致你的程序内存使用很高。这里要注意的是，修改缓存数据的时候，记得加锁。</p><p>然后后面的具体操作就是通过一致性hash算法，进行选择服务器，如果计算出来的就是本机就本机进行操作，如果是其他ip就本机使用代理访问，这样就实现了分布式操作。</p><p>设计的东西还是比较多。直接看看源代码，应该还是能看懂。我项目的写的还是比较清楚的。感兴趣的可以看看。</p><p>项目github地址：<a href="https://github.com/myxy99/shopping" target="_blank" rel="noopener">https://github.com/myxy99/shopping</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的ORM-Gorm的关联模型</title>
      <link href="/posts/golang/54a7f546.html"/>
      <url>/posts/golang/54a7f546.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="Golang中的ORM-Gorm的关联模型"><a href="#Golang中的ORM-Gorm的关联模型" class="headerlink" title="Golang中的ORM-Gorm的关联模型"></a>Golang中的ORM-Gorm的关联模型</h1><p>对于gorm的基础CRUD用法，这里就不论述了，这里主要说下关联模型的问题，因为我自己在查看官方文档进行关联模型操作的时候，总是感觉官方的例子很奇怪，用着很不明白。对于gorm的基础CRUD用法，不明白的可以看看官方文档：<a href="https://gorm.io/zh_CN/docs/models.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/models.html</a></p><h1 id="创建数据库层面的外键："><a href="#创建数据库层面的外键：" class="headerlink" title="创建数据库层面的外键："></a>创建数据库层面的外键：</h1><pre><code class="golang">models.MysqlHandler.Model(&amp;models.Order{}).AddForeignKey(&quot;user_id&quot;, &quot;user(id)&quot;, &quot;RESTRICT&quot;, &quot;RESTRICT&quot;)</code></pre><p>说说这里的RESTRICT，这里还可以填CASCADE、NO ACTION、RESTRICT、SET NULL。分别的意思是：</p><blockquote><p>CASCADE：父表delete、update的时候，子表会delete、update掉关联记录；</p><p>SET NULL：父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；</p><p>RESTRICT：如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；</p><p>NO ACTION：同 RESTRICT，也是首先先检查外键；</p></blockquote><h1 id="Belongs-To"><a href="#Belongs-To" class="headerlink" title="Belongs To"></a>Belongs To</h1><p>belongs to 关联建立一个和另一个模型的一对一连接，使得模型声明每个实例都<code>属于</code>另一个模型的一个实例 。</p><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>例如，如果你的应用包含了用户和用户所属部门， 并且每一个用户所属只分配给一个用户。模型定义：</p><pre><code class="golang">type User struct {    gorm.Model    Name string}// `Department` 属于 `User`， 外键是`UserID`type Department struct {    gorm.Model    UserID uint    User   User    Name   string}</code></pre><p>生成的表结构：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/11/20200711101256.png" alt=""></p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>默认的外键使用所有者类型名称加上其主键。像上面的例子，为了声明一个模型属于 User，它的外键应该为 UserID。</p><p>GORM 提供了一个定制外键的方法，例如:</p><pre><code class="golang">type User struct {    gorm.Model    Name string}type Department struct {  gorm.Model  Name      string  User      User `gorm:&quot;foreignkey:UserDepartment&quot;` // 使用 UserRefer 作为外键  UserDepartment uint}</code></pre><blockquote><p>后面其他连接方式也一样</p></blockquote><h2 id="关联外键"><a href="#关联外键" class="headerlink" title="关联外键"></a>关联外键</h2><p>GORM 默认使用所有者的主键作为外键值，在上面的例子中，就是 User 的 ID。当你分配一个资料给一个用户， GORM 将保存用户表的 ID 值 到 用户资料表的 UserID 字段里。你可以通过改变标签 association_foreignkey 外键值：</p><pre><code class="golang">type User struct {    gorm.Model    Department uint    Name string}type Department struct {  gorm.Model  Name      string  User      User `gorm:&quot;association_foreignkey:Refer&quot;` // use Department 作为关联外键  UserDepartment uint}</code></pre><blockquote><p>后面其他连接方式也一样</p></blockquote><h2 id="Belongs-To-的使用"><a href="#Belongs-To-的使用" class="headerlink" title="Belongs To 的使用"></a>Belongs To 的使用</h2><p>这里就是重点了，这里我直接放代码：</p><pre><code class="golang">type User struct {    gorm.Model    Name string}// `Department` 属于 `User`， 外键是`UserID`type Department struct {    gorm.Model    UserID uint    User   User    Name   string}//这里的MysqlHandler就是gorm中的数据库操作DBfunc TestGormBelongsTo(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(User{})    MysqlHandler.AutoMigrate(Department{})    //链表添加数据    //profile := Profile{    //    User: User{    //        Name: &quot;张三&quot;,    //    },    //    Name: &quot;项目组&quot;,    //}    //MysqlHandler.Create(&amp;profile)    //链表查询    //var infoList []Department    //var user User    //MysqlHandler.Preload(&quot;User&quot;).Find(&amp;infoList)    //for _, value := range infoList {    //    fmt.Println(value.Name)    //    fmt.Println(value.User.Name)    //}    // 查询添加条件 这里的条件就是 Department id为2 对应的数据    //var info Department    //info.ID = 2    //MysqlHandler.Debug().Preload(&quot;User&quot;).Find(&amp;info)    //fmt.Println(info.Name, info.User.Name)    //USER name为张三A 对应的数据    //var info Department    //MysqlHandler.Debug().Preload(&quot;User&quot;, func(query *gorm.DB) *gorm.DB {    //    return query.Where(&quot;name =? &quot;, &quot;张三A&quot;)    //}).First(&amp;info)    //fmt.Println(info.Name, info.User.Name, info.User.ID)    //    or    //var infoList []Department    //MysqlHandler.Debug().Preload(&quot;User&quot;, &quot;name =?&quot;,&quot;张三A&quot;).First(&amp;infoList)    //for _, value := range infoList {    //    fmt.Println(value.Name, value.User.Name, value.User.ID)    //}    // 使用 Related 查找 belongs to 关系    var department Department               //需要查找总的结构体    department.ID = 3                       //定义查询条件    MysqlHandler.Debug().First(&amp;department) //首先查询总表    /// SELECT * FROM `department`  WHERE `department`.`deleted_at` IS NULL AND `department`.`id` = 3 ORDER BY `department`.`id` ASC LIMIT 1    MysqlHandler.Debug().Model(&amp;department).Related(&amp;department.User) //查询子表进行赋值    /// SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`id` = 2))    fmt.Println(department.Name, &quot;---&quot;, department.User.Name, &quot;---&quot;, department.ID, &quot;---&quot;, department.User.ID)}</code></pre><p>由于gorm支持链式操作，后续需要什么操作 再往上加就行。</p><h1 id="Has-One"><a href="#Has-One" class="headerlink" title="Has One"></a>Has One</h1><h2 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h2><pre><code class="golang">//车type Car struct {    gorm.Model    Host         string //车主人名字    LicensePlate LicensePlate}//车牌type LicensePlate struct {    gorm.Model    Number string //车牌号    CarID  uint}</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>Has One的操作很Belongs To相同，可以自己实操一下。就明白了。</p><h1 id="Belongs-To跟Has-One的区别"><a href="#Belongs-To跟Has-One的区别" class="headerlink" title="Belongs To跟Has One的区别"></a>Belongs To跟Has One的区别</h1><p>同样是一对一 Belongs To跟Has One的区别是什么呢？从两个结构体不难看出差别。区别： 外键属性存在位置不同，foreignKey 指定源不同，targetKey 指定源不同</p><h1 id="Has-Many"><a href="#Has-Many" class="headerlink" title="Has Many"></a>Has Many</h1><p>has many 关联就是创建和另一个模型的一对多关系， 不像 has one，所有者可以拥有0个或多个模型实例。</p><h2 id="定义模型-2"><a href="#定义模型-2" class="headerlink" title="定义模型"></a>定义模型</h2><p>如果你的业务数据库包含学校和专业， 并且每一个学校都拥有多门专业。</p><pre><code class="golang">//学校type School struct {    gorm.Model    Name       string    Profession []Profession}//专业type Profession struct {    gorm.Model    Name     string    SchoolId uint}</code></pre><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><pre><code class="golang">func TestGormHasMany(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(School{})    MysqlHandler.AutoMigrate(Profession{})    //创建    //profession1 := Profession{Name: &quot;信息工程&quot;}    //profession2 := Profession{Name: &quot;计算机科学&quot;}    //var professionList []Profession    //professionList = append(professionList, profession1)    //professionList = append(professionList, profession2)    //school := School{    //    Name:       &quot;成都大学&quot;,    //    Profession: professionList,    //}    //MysqlHandler.Save(&amp;school) //or Create    //查询单列    //var school School    //MysqlHandler.Preload(&quot;Profession&quot;).First(&amp;school)    //fmt.Println(school)    //var school School    //MysqlHandler.First(&amp;school)    //MysqlHandler.Model(&amp;school).Related(&amp;school.Profession)    //fmt.Println(school)    //查询多列    var school []School    //MysqlHandler.First(&amp;school)    MysqlHandler.Model(&amp;school).Preload(&quot;Profession&quot;).Find(&amp;school)    for _, value := range school {        fmt.Println(value.Name, value.Profession)    }}</code></pre><h1 id="Many-To-Many"><a href="#Many-To-Many" class="headerlink" title="Many To Many"></a>Many To Many</h1><p>多对多为两个模型增加了一个中间表。</p><h2 id="定义模型-3"><a href="#定义模型-3" class="headerlink" title="定义模型"></a>定义模型</h2><p>例如，如果你的应用包含用户和语言， 一个用户会说多种语言，并且很多用户会说一种特定的语言。</p><pre><code class="golang">// 用户拥有并属于多种语言， 使用  `user_languages` 作为中间表type User struct {    gorm.Model    Languages         []Language `gorm:&quot;many2many:user_languages;&quot;`}type Language struct {    gorm.Model    Name string    Users               []User     `gorm:&quot;many2many:user_languages;&quot;`}</code></pre><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><pre><code class="golang">func TestGormManyToMany(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(Users{})    MysqlHandler.AutoMigrate(Language{})    //    创建    //langEN := Language{Name: &quot;EN&quot;}    //langCN := Language{Name: &quot;CN&quot;}    //u1 := &amp;Users{    //    Name: &quot;user1&quot;,    //    Languages: []Language{    //        langEN,    //        langCN,    //    },    //}    //MysqlHandler.Create(u1)    //LangCN := Language{}    //MysqlHandler.Where(&quot;name=?&quot;,&quot;CN&quot;).First(&amp;LangCN)    //u2 := &amp;Users{    //    Name: &quot;user2&quot;,    //    Languages: []Language{    //        LangCN,    //    },    //}    //MysqlHandler.Create(u2)    //查询    //获取 用户id 为 3 的 user 的语言：    //var users Users    //MysqlHandler.Find(&amp;users, 3)    //MysqlHandler.Model(&amp;users).Related(&amp;users.Languages, &quot;Languages&quot;)    //查询    //获取 使用语言 为 CN 的 user：    //var language Language    //MysqlHandler.Find(&amp;language, &quot;name=?&quot;,&quot;CN&quot;)    //MysqlHandler.Model(&amp;language).Related(&amp;language.Users, &quot;Users&quot;)    //fmt.Println(language)}</code></pre><p>参考连接：<a href="https://gorm.io/zh_CN/docs/" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/</a></p><p>文章代码地址：<a href="https://github.com/myxy99/shopping/blob/master/test/gorm_test.go" target="_blank" rel="noopener">https://github.com/myxy99/shopping/blob/master/test/gorm_test.go</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> orm </tag>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang微服务开发-grpc</title>
      <link href="/posts/golang/5f3710bf.html"/>
      <url>/posts/golang/5f3710bf.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 09:52:33 GMT+0800 (GMT+08:00) --><h1 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h1><p>grpc官网：<a href="https://www.grpc.io/" target="_blank" rel="noopener">https://www.grpc.io/</a></p><blockquote><p>A high-performance, open-source universal RPC framework</p></blockquote><p>这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?RPC(remote procedure call 远程过程调用),所谓RPC框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</p><p>RPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082403.png" alt=""></p><p>RPC调用过程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082506.png" alt=""></p><p>GRPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082558.png" alt=""></p><p>性能对比可以查看这篇文章：<a href="https://blog.csdn.net/xuduorui/article/details/77938644" target="_blank" rel="noopener">https://blog.csdn.net/xuduorui/article/details/77938644</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>先安装Protobuf 编译器 protoc，下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p><p>Protobuf插件库安装：</p><pre><code class="golang">// gRPC运行时接口编解码支持库go get -u github.com/golang/protobuf/proto// 从 Proto文件(gRPC接口描述文件) 生成 go文件 的编译器插件go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>go依赖包</p><pre><code class="golang">go get -u google.golang.org/grpc</code></pre><h1 id="定义服务，编写proto文件"><a href="#定义服务，编写proto文件" class="headerlink" title="定义服务，编写proto文件"></a>定义服务，编写proto文件</h1><p>编写proto文件的语法什么的，我后面会单独出一篇文章。这里就不多说语法了。</p><pre><code class="proto">syntax = &quot;proto3&quot;;package study;//  请求参数message Token {    string jwtToken = 1; //1为字段顺序    int64 timeStamp = 2;}//  返回参数message TokenR {    bool IsLogin = 1;}//  定义服务Auth//  服务方法CheckToken//  Token传入的值//  TokenR输出的值//  生成兼容grpc的go文件//  protoc --go_out=plugins=grpc:. *.protoservice Auth {    rpc CheckToken (Token) returns (TokenR);}</code></pre><h1 id="生成兼容grpc的go文件"><a href="#生成兼容grpc的go文件" class="headerlink" title="生成兼容grpc的go文件"></a>生成兼容grpc的go文件</h1><pre><code class="golang">protoc --go_out=plugins=grpc:. *.proto</code></pre><p>生成了对应的pb文件：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710083457.png" alt=""></p><h1 id="编写服务端"><a href="#编写服务端" class="headerlink" title="编写服务端"></a>编写服务端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;net&quot;)type AuthImp struct {}func (a *AuthImp) CheckToken(ctx context.Context, token *study.Token) (*study.TokenR, error) {   s := token.JwtToken   fmt.Println(s)   /**   一些列处理   */   //数据的返回   res := new(study.TokenR)   res.IsLogin = true   return res, nil}func main() {   server := grpc.NewServer()   //注册   study.RegisterAuthServer(server, new(AuthImp))   lis, err := net.Listen(&quot;tcp&quot;, &quot;:8091&quot;)   if err != nil {      panic(err.Error())   }   _ = server.Serve(lis)}</code></pre><h1 id="编写客户端"><a href="#编写客户端" class="headerlink" title="编写客户端"></a>编写客户端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;time&quot;)func main() {   //客户端连接   conn, err := grpc.Dial(&quot;localhost:8091&quot;, grpc.WithInsecure())   if err != nil {      panic(err.Error())   }   defer conn.Close()   authServiceClient := study.NewAuthClient(conn)   request := study.Token{      TimeStamp: time.Now().Unix(),      JwtToken:  &quot;3213213&quot;,   }   checkTokenClient, err := authServiceClient.CheckToken(context.Background(), &amp;request)   fmt.Println(checkTokenClient.IsLogin)}</code></pre><p>这样就完成了最简单的grpc功能。</p><p>这样的rpc接口只能在程序之间进行调用，但是我们最后的服务需要提供给用户使用，需要的是http请求。这里有几个方案进行解决：</p><blockquote><p>1.编写专门的提供http的web服务，web服务充当客户端，调用grpc。</p></blockquote><blockquote><p>2.使用GRPC Gateway: <a href="https://github.com/grpc-ecosystem/grpc-gateway/" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/grpc-gateway/</a></p></blockquote><blockquote><p>3.使用第三方拓展：<a href="https://github.com/vaporz/turbo" target="_blank" rel="noopener">https://github.com/vaporz/turbo</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> grpc </tag>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现一致性Hash算法</title>
      <link href="/posts/golang/6a0c048e.html"/>
      <url>/posts/golang/6a0c048e.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 13:21:49 GMT+0800 (GMT+08:00) --><h1 id="什么是一致性Hash算法"><a href="#什么是一致性Hash算法" class="headerlink" title="什么是一致性Hash算法"></a>什么是一致性Hash算法</h1><p>一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709195951.png" alt=""></p><p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p><p>我们把这个由2的32次方个点组成的圆环称为hash环。</p><p>假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意</p><blockquote><p>hash(服务器A的IP地址) % 2^32</p></blockquote><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201526.png" alt=""></p><p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中。所以现在的hash环：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201713.png" alt=""></p><p>这样我们的服务器就映射到了hash环上，现在我们同理也就可以把我们需要访问的对象也放在hash环上。</p><p>假设我们现在需要分别在三个服务器上放缓存的文件，我们就使用文件的名字作为计算hash的key：</p><blockquote><p>hash(文件名) % 2^32</p></blockquote><p>这样也能计算一个值，也就能映射到对应的hash环上。现在我们的hash环就变成了这个样子：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709202336.png" alt=""></p><p>计算出来了文件的hash值，下一步就是觉得那个服务器存储这个对象了。这里规定是：从计算出来的位置开始向顺时针方向遇到的第一个服务器，进行存储。所以这里文件就会存储在服务器B上。</p><p>这就是一致性hash算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>这里我们假设，我们的服务器B突然失效了,我们上面例子中的文件就会存储到服务器c中，这样就算是缓存失效。但是这里服务器失效的是A,就对上面例子中的文件不会有任何的影响。使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。这就是一致性哈希算法所体现出的优点。</p><h1 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h1><p>理想情况下我们的3个服务器是如上图所示，均匀的分布在hash环上，但是理想往往和现实差距很大：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203438.png" alt=""></p><p>实际上映射中，服务器可能会被映射成这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203659.png" alt=""></p><p>这种情况下缓存的对象很有可能大部分集中缓存在某一台服务器。这就很难受了。这就是hash环的偏斜。那么，我们应该怎样防止hash环的偏斜呢？</p><h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>虚拟节点就是来解决hash环偏斜的问题的。顾名思义就是在hash环上创建每个服务器的副本，是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点，创建副本后的hash环就变成了这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709204300.png" alt=""></p><p>这样就解决了偏移问题。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p><h1 id="Golang中实现hash环"><a href="#Golang中实现hash环" class="headerlink" title="Golang中实现hash环"></a>Golang中实现hash环</h1><pre><code class="golang">package hashimport (    &quot;errors&quot;    &quot;hash/crc32&quot;    &quot;sort&quot;    &quot;strconv&quot;    &quot;sync&quot;)//声明新切片类型type units []uint32//返回切片长度func (x units) Len() int {    return len(x)}//比对两个数大小func (x units) Less(i, j int) bool {    return x[i] &lt; x[j]}//切片中两个值的交换func (x units) Swap(i, j int) {    x[i], x[j] = x[j], x[i]}//创建结构体保存一致性hash信息type ConsistentHash struct {    //hash环，key为哈希值，值存放节点的信息    circle map[uint32]string    //已经排序的节点hash切片    sortedHashes units    //虚拟节点个数，用来增加hash的平衡性    VirtualNode int    //map 读写锁    sync.RWMutex}//创建一致性hash算法结构体，设置默认节点数量func NewConsistent(nodeNum int) *ConsistentHash {    return &amp;ConsistentHash{        //初始化变量        circle: make(map[uint32]string),        //设置虚拟节点个数        VirtualNode: nodeNum,    }}//自动生成key值func (c *ConsistentHash) generateKey(element string, index int) string {    //副本key生成逻辑    return element + strconv.Itoa(index)}//获取hash位置 计算key 在hash环中对应的位置func (c *ConsistentHash) hashKey(key string) uint32 {    //当长度不够填充    if len(key) &lt; 64 {        //声明一个数组长度为64        var tmpList [64]byte        //拷贝数据到数组中        copy(tmpList[:], key)        //使用IEEE 多项式返回数据的CRC-32校验和        return crc32.ChecksumIEEE(tmpList[:len(key)])    }    return crc32.ChecksumIEEE([]byte(key))}//更新排序，方便查找 因为后面我们使用的是sort.Search进行查找 sort.Search使用的是二分法进行查找，所以这里需要排序func (c *ConsistentHash) updateSortedHashes() {    hashes := c.sortedHashes[:0]    //判断切片容量，是否过大，如果过大则重置    if cap(c.sortedHashes)/(c.VirtualNode*4) &gt; len(c.circle) {        hashes = nil    }    //添加hashes    for k := range c.circle {        hashes = append(hashes, k)    }    //对所有节点hash值进行排序，    //方便之后进行二分查找    sort.Sort(hashes)    //重新赋值    c.sortedHashes = hashes}//向hash环中添加节点func (c *ConsistentHash) Add(element string) {    //加锁    c.Lock()    //解锁    defer c.Unlock()    c.add(element)}//添加节点func (c *ConsistentHash) add(element string) {    //循环虚拟节点，设置副本    for i := 0; i &lt; c.VirtualNode; i++ {        //根据生成的节点添加到hash环中        c.circle[c.hashKey(c.generateKey(element, i))] = element    }    //更新排序    c.updateSortedHashes()}//删除节点func (c *ConsistentHash) remove(element string) {    for i := 0; i &lt; c.VirtualNode; i++ {        delete(c.circle, c.hashKey(c.generateKey(element, i)))    }    c.updateSortedHashes()}//删除一个节点func (c *ConsistentHash) Remove(element string) {    c.Lock()    defer c.Unlock()    c.remove(element)}//顺时针查找最近的节点func (c *ConsistentHash) search(key uint32) int {    //查找算法    f := func(x int) bool {        return c.sortedHashes[x] &gt; key    }    //使用&quot;二分查找&quot;算法来搜索指定切片满足条件的最小值    i := sort.Search(len(c.sortedHashes), f)    //如果超出范围则设置i=0    if i &gt;= len(c.sortedHashes) {        i = 0    }    return i}//根据数据标示获取最近的服务器节点信息func (c *ConsistentHash) Get(name string) (string, error) {    //添加锁    c.RLock()    //解锁    defer c.RUnlock()    //如果为零则返回错误    if len(c.circle) == 0 {        return &quot;&quot;, errors.New(&quot;hash环没有数据&quot;)    }    //计算hash值    key := c.hashKey(name)    i := c.search(key)    return c.circle[c.sortedHashes[i]], nil}</code></pre><p>这样就很简单的实现了golong的一致性hash。</p><blockquote><p>这里提一下，为什么是2^32呢?因为这个算法的出现就算为了解决分布式问题，所以在分布式中基本上存储的就算服务器的ip，IPv4的地址是4组8位2进制数组成，所以用2^32可以保证每个IP地址会有唯一的映射。</p></blockquote><p>参考连接：<a href="https://www.cnblogs.com/williamjie/p/9477852.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9477852.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> 一致性Hash </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang使用jwt</title>
      <link href="/posts/golang/631d0e90.html"/>
      <url>/posts/golang/631d0e90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 08 2020 07:06:51 GMT+0800 (GMT+08:00) --><h1 id="Golang中使用JWT-json-web-token"><a href="#Golang中使用JWT-json-web-token" class="headerlink" title="Golang中使用JWT(json web token)"></a>Golang中使用JWT(json web token)</h1><h2 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h2><p>什么是jwt这里就不多说了，官网有介绍。官网介绍：<a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h3><pre><code class="golang">go get -u github.com/dgrijalva/jwt-go</code></pre><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="ini">[jwt]# 盐JwtSecret = jdnsakjbduiiudu# 过期时间（天ExpiresAt = 3# 签发Issuer = jwt</code></pre><h4 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h4><pre><code class="golang">package Utilsimport (    &quot;errors&quot;    &quot;github.com/dgrijalva/jwt-go&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;wPan/v1/Models&quot; //加载模型)// JWT 签名结构type JWT struct {    SigningKey []byte}//JWT 中存储得数据结构体 这里可以根据需求自由添加type UserInfo struct {    Id       int    `json:&quot;id&quot;`    Username string `json:&quot;username&quot;`    Email    string `json:&quot;email&quot;`    Status   int    `json:&quot;status&quot;`}// 生成JWT函数func GenerateToken(user *Models.User) (string, error) {    claim := jwt.MapClaims{        //这里为自定义        &quot;username&quot;: user.UserName,        &quot;id&quot;:       user.ID,        &quot;email&quot;:    user.Email,        &quot;status&quot;:   user.Status,        //到这里，后面都是必须的        &quot;nbf&quot;: time.Now().Unix(),        &quot;iat&quot;: time.Now().Unix(),        //设置过期时间        &quot;exp&quot;: time.Now().Unix() + Config.JWTSetting.ExpiresAt*60*60,        //签名方        &quot;iss&quot;: Config.JWTSetting.Issuer,    }    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)    tokens, err := token.SignedString([]byte(Config.JWTSetting.JwtSecret))    return tokens, err}//设置盐func secret() jwt.Keyfunc {    return func(token *jwt.Token) (interface{}, error) {        return []byte(Config.JWTSetting.JwtSecret), nil    }}//token 验证func ParseToken(tokens string) (user *UserInfo, err error) {    user = &amp;UserInfo{}    token, err := jwt.Parse(tokens, secret())    if err != nil {        return    }    claim, ok := token.Claims.(jwt.MapClaims)    if !ok {        err = errors.New(&quot;cannot convert claim to mapclaim&quot;)        return    }    //验证token，如果token被修改过则为false    if !token.Valid {        err = errors.New(&quot;token is invalid&quot;)        return    }    //提取当初我们生成时候存储的数据    user.Id = int(claim[&quot;id&quot;].(float64))    user.Username = claim[&quot;username&quot;].(string)    user.Email = claim[&quot;email&quot;].(string)    user.Status = int(claim[&quot;status&quot;].(float64))    return}</code></pre><p>Service中的使用</p><pre><code class="golang">func GetJwt(u *Models.User) (string, bool) {    token, err := Utils.GenerateToken(u)    if err != nil {        return &quot;&quot;, false    }    return token, true}</code></pre><h4 id="编写验证中间件"><a href="#编写验证中间件" class="headerlink" title="编写验证中间件"></a>编写验证中间件</h4><p>我这里使用的gin框架，其他的框架也类似</p><pre><code class="golang">func Auth() gin.HandlerFunc {    return func(c *gin.Context) {        token := c.GetHeader(&quot;Authorization&quot;)        userInfo, err := Utils.ParseToken(token[7:])        if err != nil {            R.Response(c, http.StatusUnauthorized, R.AUTH_ERROR, nil, http.StatusUnauthorized)            c.Abort()            return        }        c.Set(&quot;userInfo&quot;, userInfo)        c.Next()        return    }}</code></pre><h4 id="路由中使用"><a href="#路由中使用" class="headerlink" title="路由中使用"></a>路由中使用</h4><pre><code class="golang">authApi.GET(&quot;/info&quot;, Middleware.Auth(), Controllers.Info)</code></pre><p>这样用户再访问需要验证的请求时，就需要请求头中带上<code>Authorization</code>，value为token。</p><p>参考连接：<a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">https://github.com/dgrijalva/jwt-go</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protoc-go修改生成的文件的结构体的tag</title>
      <link href="/posts/golang/9e0030b.html"/>
      <url>/posts/golang/9e0030b.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个<code>omitempty</code>，这个的作用呢，就是在数据传输过程中，自动去掉<code>false 0 &quot;&quot;</code>这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的<code>omitempty</code>。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710092950.png" alt=""></p><p>git地址：<a href="https://github.com/favadi/protoc-go-inject-tag" target="_blank" rel="noopener">https://github.com/favadi/protoc-go-inject-tag</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="golang">go get github.com/favadi/protoc-go-inject-tag</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="只需要在-proto文件中写注释"><a href="#只需要在-proto文件中写注释" class="headerlink" title="只需要在.proto文件中写注释"></a>只需要在.proto文件中写注释</h2><pre><code class="proto">syntax = &quot;proto3&quot;;package study;//  请求参数message Token {    // @inject_tag: json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;    string jwtToken = 1; //1为字段顺序    // @inject_tag: json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;    int64 timeStamp = 2;}//  返回参数message TokenRequest {    // @inject_tag: json:&quot;isLogin&quot; form:&quot;isLogin&quot;    bool IsLogin = 1;}//  定义服务Auth//  服务方法CheckToken//  Token传入的值//  TokenRequest输出的值//  生成兼容grpc的go文件//  protoc --go_out=plugins=grpc:. *.protoservice Auth {    rpc CheckToken (Token) returns (TokenRequest);}</code></pre><h2 id="执行生成pb文件"><a href="#执行生成pb文件" class="headerlink" title="执行生成pb文件"></a>执行生成pb文件</h2><pre><code class="golang">protoc --go_out=plugins=grpc:. *.proto</code></pre><h2 id="执行修改tag-命令"><a href="#执行修改tag-命令" class="headerlink" title="执行修改tag 命令"></a>执行修改tag 命令</h2><pre><code class="golang">protoc-go-inject-tag -input=./*.pb.go</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710095030.png" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>这个时候查看生成的文件就变成了这样</p><pre><code class="golang">//  请求参数type Token struct {    state         protoimpl.MessageState    sizeCache     protoimpl.SizeCache    unknownFields protoimpl.UnknownFields    // @inject_tag: json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;    JwtToken string `protobuf:&quot;bytes,1,opt,name=jwtToken,proto3&quot; json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;` //1为字段顺序    // @inject_tag: json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;    TimeStamp int64 `protobuf:&quot;varint,2,opt,name=timeStamp,proto3&quot; json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;`}//  返回参数type TokenRequest struct {    state         protoimpl.MessageState    sizeCache     protoimpl.SizeCache    unknownFields protoimpl.UnknownFields    // @inject_tag: json:&quot;isLogin&quot; form:&quot;isLogin&quot;    IsLogin bool `protobuf:&quot;varint,1,opt,name=IsLogin,proto3&quot; json:&quot;isLogin&quot; form:&quot;isLogin&quot;`}</code></pre><p>这样就行了，还可以根据自己的需求，自定义tag</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
            <tag> go-micro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现依赖注入+gin</title>
      <link href="/posts/golang/8f49d9e3.html"/>
      <url>/posts/golang/8f49d9e3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="Go实现依赖注入"><a href="#Go实现依赖注入" class="headerlink" title="Go实现依赖注入"></a>Go实现依赖注入</h1><p>最近在使用go开发的时候，发现构建系统依赖树非常繁琐，需要手动去new很多对象，又手工代码将它们拼接起来，写了一堆非常冗繁的代码。之前在laravel的使用中有其强大的ioc，都没有这方面的困扰。就在想golang中有没有好用的依赖注入方案，查询资料，发现了facebook团队开源的inject。GitHub地址：<a href="http://github.com/facebookgo/inject" target="_blank" rel="noopener">http://github.com/facebookgo/inject</a></p><p>没有依赖注入的系统：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709104638.png" alt=""></p><p>在代码上的表现：</p><pre><code class="golang">func NewUserRepository() UserRepositoryImp {    return &amp;UserManagerRepository{        Db: models.MysqlHandler,    }}func NewUserServices(repository repositories.UserRepositoryImp) UserServiceImp {    return &amp;UserService{repository}}func NewUserController(userServices services.UserServiceImp) UserImp {    return &amp;UserController{UserServices: userServices}}repository := repositories.NewUserRepository()userServices := services.NewUserServices(repository)controller := controllers.NewUserController(userServices)</code></pre><p>这里也能看出口想当的难受。而且重复代码很多。</p><h2 id="使用的依赖"><a href="#使用的依赖" class="headerlink" title="使用的依赖"></a>使用的依赖</h2><pre><code class="golang">go get github.com/facebookgo/inject</code></pre><h2 id="简单的使用例子"><a href="#简单的使用例子" class="headerlink" title="简单的使用例子"></a>简单的使用例子</h2><pre><code class="golang">type DBEngine struct {    Name string}type UserDB struct {    Db *DBEngine `inject:&quot;&quot;`}type UserService struct {    Db *UserDB `inject:&quot;&quot;`}type App struct {    Name string    User *UserService `inject:&quot;&quot;`}func (a *App) Create() string {    return &quot;create app, in db name:&quot; + a.User.Db.Db.Name + &quot; app name :&quot; + a.Name}type Object struct {    App *App}func Init() *Object {    var g inject.Graph    // 不适用依赖注入    //a := DBEngine{Name: &quot;db1&quot;}    //b := UserDB{&amp;a}    //c := UserService{&amp;b}    //app := App{Name: &quot;go-app&quot;, User: &amp;c}    app := App{Name: &quot;go-app&quot;}    _ = g.Provide(        &amp;inject.Object{Value: &amp;DBEngine{Name: &quot;db1&quot;}},        &amp;inject.Object{Value: &amp;app},    )    _ = g.Populate()    return &amp;Object{        App: &amp;app,    }}func TestMains(t *testing.T) {    obj := Init()    fmt.Println(obj.App.Create())}</code></pre><p>这样很简单就实现了golang的依赖注入，看这个开源库的源码发现，整个类库的实现才500多行代码。这是多么轻量级的一个类库，只不过代码这么短，功能也不会太多，相比laravel的依赖注入而言，它的功能就单一太多了。不过没关系，相比Guice而言这些缺失的功能不是必须的，能帮我们省掉很多代码它已经做得很好了，这就足够了。</p><p>所以最上面的代码就可以修改为：</p><pre><code class="golang">    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()</code></pre><h2 id="在gin使用依赖注入"><a href="#在gin使用依赖注入" class="headerlink" title="在gin使用依赖注入"></a>在gin使用依赖注入</h2><pre><code class="golang">func TestInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //使用 Inject New方法就不用写了    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, userController.Login)        api.POST(&quot;/register&quot;, userController.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), userController.Info)    }    _ = app.Run(&quot;:8080&quot;)}func TestNoInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //不使用 Inject    repository := repositories.NewUserRepository()    userServices := services.NewUserServices(repository)    controller := controllers.NewUserController(userServices)    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, controller.Login)        api.POST(&quot;/register&quot;, controller.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), controller.Info)    }    _ = app.Run(&quot;:8080&quot;)}</code></pre><p>源码：<a href="https://github.com/myxy99/shopping" target="_blank" rel="noopener">https://github.com/myxy99/shopping</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> inject </tag>
            
            <tag> gin </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现RabbitMQ五种模式</title>
      <link href="/posts/golang/4b90efe7.html"/>
      <url>/posts/golang/4b90efe7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="使用的依赖包"><a href="#使用的依赖包" class="headerlink" title="使用的依赖包"></a>使用的依赖包</h1><pre><code class="golang">github.com/streadway/amqp</code></pre><h1 id="创建RabbitMQ实例"><a href="#创建RabbitMQ实例" class="headerlink" title="创建RabbitMQ实例"></a>创建RabbitMQ实例</h1><pre><code class="golang">package RabbitMQimport (    &quot;fmt&quot;    &quot;github.com/streadway/amqp&quot;    &quot;log&quot;)// 用户名 密码 ip:端口/虚拟机const MQURL = &quot;amqp://admin:123456@127.0.0.1:5672/test&quot;type RabbitMQ struct {    conn    *amqp.Connection    channel *amqp.Channel    //队列名称    QueueName string    //交换机    Exchange string    //key    key string    //连接信息    MqUrl string}//创建RabbitMQ结构体实例func NewRabbitMQ(queueName, exchange, key string) *RabbitMQ {    rabbitmq := &amp;RabbitMQ{QueueName: queueName, Exchange: exchange, key: key, MqUrl: MQURL}    var err error    //创建RabbitMQ连接    rabbitmq.conn, err = amqp.Dial(rabbitmq.MqUrl)    rabbitmq.failOnErr(err, &quot;创建连接错误!&quot;)    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;获取channel失败!&quot;)    return rabbitmq}//断开channel和connectionfunc (r *RabbitMQ) Destroy() {    r.channel.Close()    r.conn.Close()}//错误处理函数func (r *RabbitMQ) failOnErr(err error, message string) {    if err != nil {        log.Fatalf(&quot;%s:%s&quot;, message, err)        panic(fmt.Sprintf(&quot;%s,%s&quot;, message, err))    }}</code></pre><h1 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h1><p>Simple模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708092914.png" alt="Simple模式"></p><pre><code class="golang">//创建简单模式下RabbitMQ实例func NewRabbitMQSimple(queueName string) *RabbitMQ {    return NewRabbitMQ(queueName, &quot;&quot;, &quot;&quot;)}//简单模式下生产代码func (r *RabbitMQ) PublishSimple(message string) {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil,    )    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.发送消息到队列中    err = r.channel.Publish(        r.Exchange,        r.QueueName,        //如果为true,根据exchange类型和routekey规则,如果无法找到符合条件的队列那么会把发送的消息返回给发送者        false,        //如果为true,当exchange发送消息队列到队列后发现队列上没有绑定消费者,则会把消息发还给发送者        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })    if err != nil {        fmt.Println(&quot;Publish:&quot;, err)    }}//简单模式下消费代码func (r *RabbitMQ) ConsumeSimple() {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil)    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.接受消息    msgs, err := r.channel.Consume(        r.QueueName,        //用来区分多个消费者        &quot;&quot;,        //是否自动应答        true,        //是否具有排他性        false,        //如果设置为true,表示不能将同一个connection中发送消息传递给这个connection中的消费者        false,        //队列消费是否阻塞        false,        nil)    if err != nil {        fmt.Println(&quot;Consume:&quot;, err)    }    forever := make(chan bool)    //3.启用协程处理消息    go func() {        for d := range msgs {            //实现我们要处理的逻辑函数            log.Printf(&quot;Received a message:%s&quot;, d.Body)        }    }()    log.Printf(&quot;[*] Waiting for messages,To exit press CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="简单模式publish"><a href="#简单模式publish" class="headerlink" title="简单模式publish"></a>简单模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;go-rabbitmq/RabbitMQ&quot;)func main()  {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.PublishSimple(&quot;myxy99.cn msg&quot;)    fmt.Println(&quot;发送成功!&quot;)}</code></pre><h2 id="简单模式recevie"><a href="#简单模式recevie" class="headerlink" title="简单模式recevie"></a>简单模式recevie</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="Work模式"><a href="#Work模式" class="headerlink" title="Work模式"></a>Work模式</h1><p>Work模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708093050.png" alt="Work模式"></p><p>simple模式和work模式其实用的是一套逻辑代码，只是work模式是可以有多个消费者的，work模式起到一个负载均衡的作用。</p><h2 id="work模式publish"><a href="#work模式publish" class="headerlink" title="work模式publish"></a>work模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    for i := 0; i &lt;= 100; i++ {        rabbitmq.PublishSimple(&quot;Hello test!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="work模式receive1"><a href="#work模式receive1" class="headerlink" title="work模式receive1"></a>work模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h2 id="work模式receive2"><a href="#work模式receive2" class="headerlink" title="work模式receive2"></a>work模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><p>订阅模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708095831.png" alt=""></p><p>订阅模式的特别是：一个消息被投递到多个队列，一个消息能被多个消费者获取。过程是由生产者将消息发送到exchange(交换机）里，然后exchange通过一系列的规则发送到队列上，然后由绑定对应的消费者进行消息。</p><pre><code class="golang">//订阅模式创建RabbitMQ实例func NewRabbitMQPubSub(exchangeName string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,&quot;&quot;)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//订阅模式生产func (r *RabbitMQ) PublishPub(message string) {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        &quot;fanout&quot;,        true,        false,        //true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        &quot;&quot;,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//订阅模式消费端代码func (r *RabbitMQ) RecieveSub() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;fanout&quot;,        true,        false,        //YES表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        &quot;&quot;,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="订阅模式publish"><a href="#订阅模式publish" class="headerlink" title="订阅模式publish"></a>订阅模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    for i := 0; i &lt; 100; i++ {        rabbitmq.PublishPub(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        fmt.Println(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        time.Sleep(1 * time.Second)    }}</code></pre><h2 id="订阅模式receive1"><a href="#订阅模式receive1" class="headerlink" title="订阅模式receive1"></a>订阅模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h2 id="订阅模式receive2"><a href="#订阅模式receive2" class="headerlink" title="订阅模式receive2"></a>订阅模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h1 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h1><p>路由模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100024.png" alt=""></p><p>路由模式:一个消息由多个消费者消费的基础上指定由哪些消息者来消费。</p><pre><code class="golang">func NewRabbitMQRouting(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//路由模式发送消息func (r *RabbitMQ) PublishRouting(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成direct        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exchange&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//路由模式接受消息func (r *RabbitMQ) RecieveRouting() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //需要绑定key        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="路由模式publish"><a href="#路由模式publish" class="headerlink" title="路由模式publish"></a>路由模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishRouting(&quot;Hello myxy99 one!&quot; + strconv.Itoa(i))        mqTwo.PublishRouting(&quot;Hello myxy99 Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="路由模式receive-one"><a href="#路由模式receive-one" class="headerlink" title="路由模式receive-one"></a>路由模式receive-one</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mq.RecieveRouting()}</code></pre><h2 id="路由模式receive-two"><a href="#路由模式receive-two" class="headerlink" title="路由模式receive-two"></a>路由模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    mq.RecieveRouting()}</code></pre><h1 id="话题模式"><a href="#话题模式" class="headerlink" title="话题模式"></a>话题模式</h1><p>话题模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100143.png" alt=""></p><p>话题模式：话题模式是在路由模式上演化而来。不同的是我们以通配符的方式来指定我们的消费者。</p><pre><code class="golang">//话题模式//创建RabbitMQ实例func NewRabbitMQTopic(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//话题模式发送消息func (r *RabbitMQ) PublishTopic(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成topic        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//话题模式接受消息//要注意key,规则//其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）//匹配 myxy99.* 表示匹配 myxy99.hello, 但是myxy99.hello.one需要用myxy99.#才能匹配到func (r *RabbitMQ) RecieveTopic() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="话题模式publish"><a href="#话题模式publish" class="headerlink" title="话题模式publish"></a>话题模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishTopic(&quot;Hello myxy99 topic one!&quot; + strconv.Itoa(i))        mqTwo.PublishTopic(&quot;Hello myxy99 topic Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="话题模式receive-all"><a href="#话题模式receive-all" class="headerlink" title="话题模式receive-all"></a>话题模式receive-all</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;#&quot;)    mq.RecieveTopic()}</code></pre><h2 id="话题模式receive-two"><a href="#话题模式receive-two" class="headerlink" title="话题模式receive-two"></a>话题模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.*.two&quot;)    mq.RecieveTopic()}</code></pre><p>GitHub地址：<a href="https://github.com/myxy99/Go-RabbitMQ" target="_blank" rel="noopener">https://github.com/myxy99/Go-RabbitMQ</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Redis简易封装</title>
      <link href="/posts/golang/b9458491.html"/>
      <url>/posts/golang/b9458491.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="Golang-Redis"><a href="#Golang-Redis" class="headerlink" title="Golang Redis"></a>Golang Redis</h1><h2 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h2><pre><code class="golang">go get github.com/gomodule/redigo</code></pre><h2 id="Redis-操作封装"><a href="#Redis-操作封装" class="headerlink" title="Redis 操作封装"></a>Redis 操作封装</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="ini">[redis]Host = 127.0.0.1:6379Password =MaxIdle = 30MaxActive = 30IdleTimeout = 200</code></pre><h3 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h3><pre><code class="golang">package Redisimport (    &quot;encoding/json&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;github.com/gomodule/redigo/redis&quot;)//定义redis连接池var Conn *redis.Pool//初始化func InitRedis() error {    Conn = &amp;redis.Pool{        MaxIdle:     Config.RedisSetting.MaxIdle,        MaxActive:   Config.RedisSetting.MaxActive,        IdleTimeout: Config.RedisSetting.IdleTimeout,        Dial: func() (redis.Conn, error) {            c, err := redis.Dial(&quot;tcp&quot;, Config.RedisSetting.Host)            if err != nil {                return nil, err            }            if Config.RedisSetting.Password != &quot;&quot; {                if _, err := c.Do(&quot;AUTH&quot;, Config.RedisSetting.Password); err != nil {                    _ = c.Close()                    return nil, err                }            }            return c, err        },        TestOnBorrow: func(c redis.Conn, t time.Time) error {            _, err := c.Do(&quot;PING&quot;)            return err        },    }    return nil}//redis 设置函数func Set(key string, data interface{}, time int) (bool, error) {    conn := Conn.Get()    defer conn.Close()    value, err := json.Marshal(data)    if err != nil {        return false, err    }    reply, err := redis.String(conn.Do(&quot;SET&quot;, key, value))    _, _ = conn.Do(&quot;EXPIRE&quot;, key, time)    return reply == &quot;OK&quot;, err}//redis 检测存在函数func Exists(key string) bool {    conn := Conn.Get()    defer conn.Close()    exists, err := redis.Bool(conn.Do(&quot;EXISTS&quot;, key))    if err != nil {        return false    }    return exists}//redis 获取函数func Get(key string) ([]byte, error) {    conn := Conn.Get()    defer conn.Close()    reply, err := redis.Bytes(conn.Do(&quot;GET&quot;, key))    if err != nil {        return nil, err    }    return reply, nil}//redis 删除函数func Delete(key string) (bool, error) {    conn := Conn.Get()    defer conn.Close()    return redis.Bool(conn.Do(&quot;DEL&quot;, key))}//redis 模糊删除函数func LikeDeletes(key string) error {    conn := Conn.Get()    defer conn.Close()    keys, err := redis.Strings(conn.Do(&quot;KEYS&quot;, &quot;*&quot;+key+&quot;*&quot;))    if err != nil {        return err    }    for _, key := range keys {        _, err = Delete(key)        if err != nil {            return err        }    }    return nil}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="golang">if err := Redis.InitRedis(); err != nil {    log.Println(&quot;init redis failed, err:&quot; + err.Error())    return}</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code class="golang">...if Redis.Exists(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...if Redis.Get(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...</code></pre><p>使用很简单这里就不一一举例了。通过这样的封装redis操作就变得更加简单了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang邮件发送</title>
      <link href="/posts/golang/4db013d1.html"/>
      <url>/posts/golang/4db013d1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><pre><code class="golang">go get github.com/jordan-wright/email</code></pre><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;net/smtp&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    e := email.NewEmail()    //设置发送方的邮箱    e.From = &quot;112233 &lt;XXX@qq.com&gt;&quot;    // 设置接收方的邮箱    e.To = []string{&quot;XXX@qq.com&quot;}    //设置主题    e.Subject = &quot;这是主题&quot;    //设置文件发送的内容    e.Text = []byte(&quot;发送的内容&quot;)    //设置服务器相关的配置    err := e.Send(&quot;smtp.qq.com:25&quot;, smtp.PlainAuth(&quot;&quot;, &quot;你的邮箱账号&quot;, &quot;这块是你的授权码&quot;, &quot;smtp.qq.com&quot;))    if err != nil {       ....    }}</code></pre><h2 id="实现抄送功能"><a href="#实现抄送功能" class="headerlink" title="实现抄送功能"></a>实现抄送功能</h2><pre><code class="golang">func main() {    ...    //设置抄送如果抄送多人逗号隔开    e.Cc = []string{&quot;XXX@qq.com&quot;,XXX@qq.com}    //设置秘密抄送    e.Bcc = []string{&quot;XXX@qq.com&quot;}    ...}</code></pre><h2 id="发送html代码的邮件"><a href="#发送html代码的邮件" class="headerlink" title="发送html代码的邮件"></a>发送html代码的邮件</h2><pre><code class="golang">func main() {    ...    e.HTML = []byte(`    &lt;h1&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/h1&gt;        `)    ...}</code></pre><h2 id="实现邮件附件的发送"><a href="#实现邮件附件的发送" class="headerlink" title="实现邮件附件的发送"></a>实现邮件附件的发送</h2><pre><code class="golang">func main() {    ...    e.AttachFile(&quot;./test.txt&quot;)    ...}</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>每次调用Send时都会和 SMTP 服务器建立一次连接，如果发送邮件很多很频繁的话可能会有性能问题。email提供了连接池，可以复用网络连接：</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net/smtp&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    ch := make(chan *email.Email, 10)    p, err := email.NewPool(        &quot;smtp.qq.com:25&quot;,        4,        smtp.PlainAuth(&quot;&quot;, &quot;XXX@qq.com&quot;, &quot;你的授权码&quot;, &quot;smtp.qq.com&quot;),    )    if err != nil {        log.Fatal(&quot;failed to create pool:&quot;, err)    }    var wg sync.WaitGroup    wg.Add(4)    for i := 0; i &lt; 4; i++ {        go func() {            defer wg.Done()            for e := range ch {                err := p.Send(e, 10*time.Second)                if err != nil {                    fmt.Fprintf(os.Stderr, &quot;email:%v sent error:%v\n&quot;, e, err)                }            }        }()    }    for i := 0; i &lt; 10; i++ {        e := email.NewEmail()        e.From = &quot;dj &lt;XXX@qq.com&gt;&quot;        e.To = []string{&quot;XXX@qq.com&quot;}        e.Subject = &quot;Awesome web&quot;        e.Text = []byte(fmt.Sprintf(&quot;Awesome Web %d&quot;, i+1))        ch &lt;- e    }    close(ch)    wg.Wait()}</code></pre><p>上面程序中，我们创建 4 goroutine 共用一个连接池发送邮件，发送 10 封邮件后程序退出。为了等邮件都发送完成或失败，程序才退出，我们使用了sync.WaitGroup。由于使用了 goroutine，邮件顺序不能保证。</p><p>参考连接：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/posts/jenkins/87b776c7.html"/>
      <url>/posts/jenkins/87b776c7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:43 GMT+0800 (GMT+08:00) --><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出</p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/posts/golang/41aae1e1.html"/>
      <url>/posts/golang/41aae1e1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 15 2020 12:43:44 GMT+0800 (GMT+08:00) --><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre><p>参考连接：<a href="https://www.cnblogs.com/blogbobo/p/13169714.html" target="_blank" rel="noopener">https://www.cnblogs.com/blogbobo/p/13169714.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel实现定时任务</title>
      <link href="/posts/php/7c4b1a8d.html"/>
      <url>/posts/php/7c4b1a8d.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 11:07:36 GMT+0800 (GMT+08:00) --><h1 id="laravel实现定时任务"><a href="#laravel实现定时任务" class="headerlink" title="laravel实现定时任务"></a>laravel实现定时任务</h1><p><strong>原理是通过Cron</strong></p><h2 id="Cron简介"><a href="#Cron简介" class="headerlink" title="Cron简介"></a>Cron简介</h2><p>Cron 是 UNIX、SOLARIS、LINUX 下的一个十分有用的工具，通过 Cron 脚本能使计划任务定期地在系统后台自动运行。这种计划任务在 UNIX、SOLARIS、LINUX下术语为 Cron Jobs。Crontab 则是用来记录在特定时间运行的 Cron 的一个脚本文件，Crontab 文件的每一行均遵守特定的格式：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716110047.png" alt=""></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>￼ 我们可以在服务器上通过 crontab -e 来新增或编辑 Cron 条目，通过 crontab -l 查看已存在的 Cron 条目。 在以前，开发者需要为每一个需要调度的任务编写一个 Cron 条目，这是很让人头疼的事。你的任务调度不在源码控制中，你必须使用 SSH 登录到服务器然后添加这些 Cron 条目。 Laravel 命令调度器允许你流式而又不失优雅地在 Laravel 中定义命令调度，并且服务器上只需要一个 Cron 条目即可。任务调度定义在 app/Console/Kernel.php 文件的 schedule 方法中，该方法中已经包含了一个示例。<br>使用：</p><h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h3><blockquote><p><code>crontab -e</code></p></blockquote><p>在尾部添加代码</p><blockquote><p><code>* * * * * 《php路径》 《laravel项目路径》/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1</code></p></blockquote><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716110351.png" alt=""></p><h3 id="定义调度"><a href="#定义调度" class="headerlink" title="定义调度"></a>定义调度</h3><p><strong>在App\Console\Commands下创建EmailTiming.php</strong></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716110455.png" alt=""></p><p><strong>编辑 app/Console/Kernel.php 文件，将新生成的类进行注册：</strong></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716110537.png" alt=""></p><p>常用：</p><pre><code>-&gt;cron(&#39;* * * * *&#39;);    在自定义Cron调度上运行任务-&gt;everyMinute();    每分钟运行一次任务-&gt;everyFiveMinutes();   每五分钟运行一次任务-&gt;everyTenMinutes();    每十分钟运行一次任务-&gt;everyThirtyMinutes(); 每三十分钟运行一次任务-&gt;hourly(); 每小时运行一次任务-&gt;daily();  每天凌晨零点运行任务-&gt;dailyAt(&#39;13:00&#39;); 每天13:00运行任务-&gt;twiceDaily(1, 13);    每天1:00 &amp; 13:00运行任务-&gt;weekly(); 每周运行一次任务-&gt;monthly();    每月运行一次任务-&gt;monthlyOn(4, &#39;15:00&#39;);    每月4号15:00运行一次任务-&gt;quarterly();  每个季度运行一次-&gt;yearly(); 每年运行一次-&gt;timezone(&#39;America/New_York&#39;); 设置时区</code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel-admin修改form默认的js引用</title>
      <link href="/posts/php/1f3e96e.html"/>
      <url>/posts/php/1f3e96e.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 11:06:59 GMT+0800 (GMT+08:00) --><h1 id="解决laravel-admin中form表单下拉框不是中文问题"><a href="#解决laravel-admin中form表单下拉框不是中文问题" class="headerlink" title="解决laravel-admin中form表单下拉框不是中文问题"></a>解决laravel-admin中form表单下拉框不是中文问题</h1><h4 id="最近在使用laravel-admin开发得时候。在做表单提交的时候发现默认的提醒为英文的这里我就想能不能设置为中文："><a href="#最近在使用laravel-admin开发得时候。在做表单提交的时候发现默认的提醒为英文的这里我就想能不能设置为中文：" class="headerlink" title="最近在使用laravel-admin开发得时候。在做表单提交的时候发现默认的提醒为英文的这里我就想能不能设置为中文："></a>最近在使用laravel-admin开发得时候。在做表单提交的时候发现默认的提醒为英文的这里我就想能不能设置为中文：</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716103834.png" alt=""></p><h4 id="然后我就在线怎么操作能够改为中文，我这里通过了通过在开发工具中搜索，我发现这里的渲染为js进行的："><a href="#然后我就在线怎么操作能够改为中文，我这里通过了通过在开发工具中搜索，我发现这里的渲染为js进行的：" class="headerlink" title="然后我就在线怎么操作能够改为中文，我这里通过了通过在开发工具中搜索，我发现这里的渲染为js进行的："></a>然后我就在线怎么操作能够改为中文，我这里通过了通过在开发工具中搜索，我发现这里的渲染为js进行的：</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104007.png" alt=""></p><h4 id="这里我发现在对应得文件夹中也有中文版本得js只是没有使用上："><a href="#这里我发现在对应得文件夹中也有中文版本得js只是没有使用上：" class="headerlink" title="这里我发现在对应得文件夹中也有中文版本得js只是没有使用上："></a>这里我发现在对应得文件夹中也有中文版本得js只是没有使用上：</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104113.png" alt=""></p><h4 id="所以这里我就在想怎么修改默认的js路径，于是我开始使用开发工具继续搜索这个js名"><a href="#所以这里我就在想怎么修改默认的js路径，于是我开始使用开发工具继续搜索这个js名" class="headerlink" title="所以这里我就在想怎么修改默认的js路径，于是我开始使用开发工具继续搜索这个js名"></a>所以这里我就在想怎么修改默认的js路径，于是我开始使用开发工具继续搜索这个js名</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104335.png" alt=""></p><h4 id="结果在这个文件中发现了js的设置，现在就要想怎么修改他了，直接修改他的源代码肯定是不行的，所以这里我想的就是继承这个类在进行重写变量赋值。"><a href="#结果在这个文件中发现了js的设置，现在就要想怎么修改他了，直接修改他的源代码肯定是不行的，所以这里我想的就是继承这个类在进行重写变量赋值。" class="headerlink" title="结果在这个文件中发现了js的设置，现在就要想怎么修改他了，直接修改他的源代码肯定是不行的，所以这里我想的就是继承这个类在进行重写变量赋值。"></a>结果在这个文件中发现了js的设置，现在就要想怎么修改他了，直接修改他的源代码肯定是不行的，所以这里我想的就是继承这个类在进行重写变量赋值。</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104425.png" alt=""></p><h4 id="现在的问题就是怎么让我们的类生效了，查看了官方文档发现只需要在bootstrap中注册就行了"><a href="#现在的问题就是怎么让我们的类生效了，查看了官方文档发现只需要在bootstrap中注册就行了" class="headerlink" title="现在的问题就是怎么让我们的类生效了，查看了官方文档发现只需要在bootstrap中注册就行了"></a>现在的问题就是怎么让我们的类生效了，查看了官方文档发现只需要在bootstrap中注册就行了</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104458.png" alt=""></p><h4 id="现在再查看下页面就变成中文了"><a href="#现在再查看下页面就变成中文了" class="headerlink" title="现在再查看下页面就变成中文了"></a>现在再查看下页面就变成中文了</h4><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716104532.png" alt=""></p><h4 id="这里其实就是一个小问题，但是主要是再发现问题得时候，怎么一步一步得找到问题，进行解决。记录一下这个思路"><a href="#这里其实就是一个小问题，但是主要是再发现问题得时候，怎么一步一步得找到问题，进行解决。记录一下这个思路" class="headerlink" title="这里其实就是一个小问题，但是主要是再发现问题得时候，怎么一步一步得找到问题，进行解决。记录一下这个思路"></a>这里其实就是一个小问题，但是主要是再发现问题得时候，怎么一步一步得找到问题，进行解决。记录一下这个思路</h4><p>参考连接：<a href="https://laravel-admin.org/docs/zh" target="_blank" rel="noopener">https://laravel-admin.org/docs/zh</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
            <tag> laravel-admin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel通过观察者监听模型事件</title>
      <link href="/posts/php/323529c6.html"/>
      <url>/posts/php/323529c6.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 10:48:08 GMT+0800 (GMT+08:00) --><h1 id="所有支持的模型事件"><a href="#所有支持的模型事件" class="headerlink" title="所有支持的模型事件"></a>所有支持的模型事件</h1><p>在 Eloquent 模型类上进行查询、插入、更新、删除操作时，会触发相应的模型事件（关于事件我们后面会单独讲），不管你有没有监听它们。这些事件包括：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>retrieved</td><td>获取到模型实例后触发</td></tr><tr><td>creating</td><td>插入到数据库前触发</td></tr><tr><td>created</td><td>插入到数据库后触发</td></tr><tr><td>updating</td><td>更新到数据库前触发</td></tr><tr><td>updated</td><td>更新到数据库后触发</td></tr><tr><td>saving</td><td>保存到数据库前触发（插入/更新之前，无论插入还是更新都会触发）</td></tr><tr><td>saved</td><td>保存到数据库后触发（插入/更新之后，无论插入还是更新都会触发）</td></tr><tr><td>deleting</td><td>从数据库删除记录前触发</td></tr><tr><td>deleted</td><td>从数据库删除记录后触发</td></tr><tr><td>restoring</td><td>恢复软删除记录前触发</td></tr><tr><td>restored</td><td>恢复软删除记录后触发</td></tr></tbody></table><h1 id="通过观察者监听模型事件"><a href="#通过观察者监听模型事件" class="headerlink" title="通过观察者监听模型事件"></a>通过观察者监听模型事件</h1><p>针对模型事件这种特殊的事件类型，Laravel 还为我们提供了观察者类来处理模型事件的监听。观察者可以看作是上述订阅者处理模型事件的简化版本，我们不需要自定义事件类，不需要建立映射关系，只需要在观察者类中将需要监听的事件定义为同名方法，并在相应方法中编写业务处理代码即可。当某个模型事件触发时，Eloquent 底层会去该模型上注册的观察者类中通过反射查找是否定义了对应的方法，如果定义了则执行相应的逻辑，否则忽略。</p><h2 id="创建观察者"><a href="#创建观察者" class="headerlink" title="创建观察者"></a>创建观察者</h2><p>首先，我们通过 Artisan命令初始化针对 User 模型的观察者：（laravel 5.8以上）</p><pre><code class="sh">php artisan make:observer UserObserver --model=User</code></pre><h2 id="编写处理代码"><a href="#编写处理代码" class="headerlink" title="编写处理代码"></a>编写处理代码</h2><p>默认生成的 UserObserver 会为 created、 updated、deleted、restored、forceDeleted（强制删除） 事件定义一个空方法。</p><p>你可以把前面定义的retrived、deleting、deleted 事件监听代码迁移过来，也可以将不需监听的事件方法移除，这里我们将编写保存模型时涉及的模型事件，包括 saving、creating、updating、updated、created、saved：</p><pre><code class="php">namespace App\Observers; use App\User;use Illuminate\Support\Facades\Log;classUserObserver{     public function saving(User $user){       Log::info(&#39;即将保存用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);       }    public function creating(User $user){       Log::info(&#39;即将插入用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);       }    public function updating(User $user){      Log::info(&#39;即将更新用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);      }    public function updated(User $user){      Log::info(&#39;已经更新用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);      }    public function created(User $user){     Log::info(&#39;已经插入用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);     }    public function saved(User $user){     Log::info(&#39;已经保存用户到数据库[&#39;.$user-&gt;id.&#39;]&#39;.$user-&gt;name);     } }</code></pre><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>编写好观察者后，需要将其注册到 User 模型上才能生效，我们可以在 EventServiceProvider 的 boot 方法中完成该工作：</p><pre><code class="php">public function boot(){     parent::boot();        User::observe(UserObserver::class);}</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试观察者监听模型事件。我们先编写一段添加新用户的代码：</p><pre><code class="php">$user=new User();$user-&gt;name=&#39;test1&#39;;$user-&gt;email=&#39;239999@qq.com&#39;;$user-&gt;password=bcrypt(&#39;123456&#39;);$user-&gt;save();</code></pre><p>执行上述代码后，即可在日志文件中看到相应的日志记录：</p><pre><code class="log">[2019-11-13 10:30:00] local.INFO: 即将保存用户到数据库[]test1  [2019-11-13 10:30:00] local.INFO: 即将插入用户到数据库[]test1  [2019-11-13 10:30:00] local.INFO: 已经插入用户到数据库[19]test1  [2019-11-13 10:30:00] local.INFO: 已经保存用户到数据库[19]test1  </code></pre><p>编写一段更新已存在用户的代码：</p><pre><code class="php">$user= User::findOrFail(15);$user-&gt;name=&#39;test2&#39;;$user-&gt;save();</code></pre><p>执行上述代码，对应的日志记录如下：</p><pre><code class="log">[2019-11-13 10:33:00] local.INFO: 从模型中获取用户[15]:Miss Lucile Langosh V  [2019-11-13 10:33:00] local.INFO: 即将保存用户到数据库[15]test2 [2019-11-13 10:33:00] local.INFO: 即将更新用户到数据库[15]test2  [2019-11-13 10:33:00] local.INFO: 已经更新用户到数据库[15]test2 [2019-11-13 10:33:00] local.INFO: 已经保存用户到数据库[15]test2</code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel的Requests验证表单优化</title>
      <link href="/posts/php/4d96b68.html"/>
      <url>/posts/php/4d96b68.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 22:25:08 GMT+0800 (GMT+08:00) --><h1 id="laravel的Requests验证表单优化"><a href="#laravel的Requests验证表单优化" class="headerlink" title="laravel的Requests验证表单优化"></a>laravel的Requests验证表单优化</h1><h2 id="首先使用-artisan-建立-request"><a href="#首先使用-artisan-建立-request" class="headerlink" title="首先使用 artisan 建立 request"></a>首先使用 artisan 建立 request</h2><pre><code class="sh"> php artisan make:request 方法名</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111217.png" alt=""></p><p>就会在app/requests下生成对应文件名</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111253.png" alt=""></p><h2 id="验证用户权限"><a href="#验证用户权限" class="headerlink" title="验证用户权限"></a>验证用户权限</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111322.png" alt=""></p><h2 id="添加验证规则具体验证规则常考laravel手册"><a href="#添加验证规则具体验证规则常考laravel手册" class="headerlink" title="添加验证规则具体验证规则常考laravel手册"></a>添加验证规则具体验证规则常考laravel手册</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111347.png" alt=""></p><h2 id="设置返回提示内容"><a href="#设置返回提示内容" class="headerlink" title="设置返回提示内容"></a>设置返回提示内容</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111406.png" alt=""></p><h2 id="返回json"><a href="#返回json" class="headerlink" title="返回json"></a>返回json</h2><p>这样就可以进行表单验证了，如果是前后分离，就需要返回的为json的数据给前台，就可以重写方法failedValidation</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111450.png" alt=""></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111522.png" alt=""></p><p><strong>返回示例：</strong></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111728.png" alt=""></p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code class="php">&lt;?phpnamespace App\Http\Requests;use Illuminate\Foundation\Http\FormRequest;use Illuminate\Contracts\Validation\Validator;use Illuminate\Http\Exceptions\HttpResponseException;class LoginPost extends FormRequest{    /**     * Determine if the user is authorized to make this request.     *     * @return bool     */    //验证用户权限  true 为有权限    public function authorize()    {        return true;    }    /**     * Get the validation rules that apply to the request.     *     * @return array     */    public function rules()    {        return [            &#39;user_name&#39;=&gt;&#39;required&#39;,            &#39;user_pwd&#39;=&gt;&#39;required&#39;        ];    }    public function messages()    {        return [            &#39;user_name.required&#39;=&gt;&#39;用户名不能为空&#39;,            &#39;user_pwd.required&#39;=&gt;&#39;密码不能为空&#39;,        ];    }    protected function failedValidation(Validator $validator)    {        throw (new HttpResponseException(response()-&gt;json([            &#39;code&#39;=&gt;100,            $validator-&gt;errors(),        ],422)));    }}</code></pre><h2 id="前台ajax-返回错误信息"><a href="#前台ajax-返回错误信息" class="headerlink" title="前台ajax 返回错误信息"></a>前台ajax 返回错误信息</h2><pre><code class="js">error: function (msg) {    const json = JSON.parse(msg.responseText)[0];    var text = &quot;&quot;;    let x;    for (x in json) {        text += json[x];        text += &#39;&lt;br&gt;&#39;;    }    layer.alert(text, {title: &#39;提示&#39;, icon: 2});}</code></pre><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>在后面的项目开发的时候，感觉前端的交互在错误渲染上，不太友好，前端交互不方便，这里我们处理了一下代码，现在得错误返回就是这样得：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111908.png" alt=""></p><p>这样前端只需要直接渲染这个数组就行了，具体的代码实现也简单，只需要修改failedValidation方法就行：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716111957.png" alt=""></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php对后台返回数据进行加密</title>
      <link href="/posts/php/b204c5a4.html"/>
      <url>/posts/php/b204c5a4.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 22:44:29 GMT+0800 (GMT+08:00) --><h1 id="php对后台返回数据进行加密，前端进行解密"><a href="#php对后台返回数据进行加密，前端进行解密" class="headerlink" title="php对后台返回数据进行加密，前端进行解密"></a>php对后台返回数据进行加密，前端进行解密</h1><h2 id="生成加密密钥"><a href="#生成加密密钥" class="headerlink" title="生成加密密钥"></a>生成加密密钥</h2><p>生成私钥：</p><pre><code class="sh">openssl genrsa -out rsa_1024_priv.pem 1024</code></pre><p>生成对应的公钥：</p><pre><code class="sh">openssl rsa -pubout -in rsa_1024_priv.pem -out rsa_1024_pub.pem</code></pre><h2 id="php加密解密代码"><a href="#php加密解密代码" class="headerlink" title="php加密解密代码"></a>php加密解密代码</h2><p><strong>注意:</strong><br>​明文长度最大为公钥长度-11，假如我的公钥长度是128，那明文最长也就117，所以下面加密我使用了循环，分段加密</p><pre><code class="php">if (!function_exists(&#39;privateDecrypt&#39;)) {    /**     * //解密     * @param string $encryptString     * @return string     */    function privateDecrypt($encryptString = &#39;&#39;)    {        $privateKey = storage_path(&#39;key/exam.key&#39;);        $decrypted = &#39;&#39;;        foreach (explode(&quot;__&amp;_&amp;__&quot;, base64_decode($encryptString)) as $chunk) {            openssl_private_decrypt($chunk, $decryptData, file_get_contents($privateKey));            $decrypted .= $decryptData;        }        return $decrypted;    }}if (!function_exists(&#39;publicEncrypt&#39;)) {    /**     * //加密     * @param string $data     * @return string     */    function publicEncrypt($data = &#39;&#39;)    {        $publicKey = storage_path(&#39;key/exam_pub.key&#39;);        $encrypt_data = &#39;&#39;;        foreach (str_split(json_encode($data), 117) as $chunk) {            openssl_public_encrypt($chunk, $encryptData, file_get_contents($publicKey));            $encrypt_data .= base64_encode($encryptData) . &quot;__&amp;_&amp;__&quot;;        }        return $encrypt_data;    }}</code></pre><h2 id="前端js的解密："><a href="#前端js的解密：" class="headerlink" title="前端js的解密："></a>前端js的解密：</h2><p>encrypted为加密后的数据</p><pre><code class="js">&lt;script src=&quot;http://code.jquery.com/jquery-1.8.3.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bin/jsencrypt.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(function () {    //公钥    var pub_key = &#39;-----BEGIN PUBLIC KEY-----\n&#39; +        &#39;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDlOJu6TyygqxfWT7eLtGDwajtN\n&#39; +        &#39;FOb9I5XRb6khyfD1Yt3YiCgQWMNW649887VGJiGr/L5i2osbl8C9+WJTeucF+S76\n&#39; +        &#39;xFxdU6jE0NQ+Z+zEdhUTooNRaY5nZiu5PgDB0ED/ZKBUSLKL7eibMxZtMlUDHjm4\n&#39; +        &#39;gwQco1KRMDSmXSMkDwIDAQAB\n&#39; +        &#39;-----END PUBLIC KEY-----&#39;;    //new JSEncrypt    var js_encrypt = new JSEncrypt();    //初始化公钥    js_encrypt.setPublicKey(pub_key);    //通过 公钥 解密    var uncrypted = js_encrypt.decrypt(encrypted);    console.log(uncrypted);});&lt;/script&gt;</code></pre><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel自定义API返回的JSON格式</title>
      <link href="/posts/php/448823f0.html"/>
      <url>/posts/php/448823f0.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 16 2020 22:44:29 GMT+0800 (GMT+08:00) --><h1 id="laravel-自定义API返回的JSON格式"><a href="#laravel-自定义API返回的JSON格式" class="headerlink" title="laravel 自定义API返回的JSON格式"></a>laravel 自定义API返回的JSON格式</h1><p><strong>在最近开发项目的时候使用Laravel框架，对api进行返回数据的时候，在团队开发的时候太随意了，缺少一个统一的结构来包装返回值，所以就需要进行返回格式的统一</strong></p><p><strong>这里我就介绍两个方法：</strong></p><h1 id="ServiceProvider方法"><a href="#ServiceProvider方法" class="headerlink" title="ServiceProvider方法"></a>ServiceProvider方法</h1><h2 id="创建一个ServiceProvider"><a href="#创建一个ServiceProvider" class="headerlink" title="创建一个ServiceProvider"></a>创建一个ServiceProvider</h2><p>命令行输入：</p><pre><code class="sh">php artisan make:provider ResponseServiceProvider</code></pre><h2 id="在boot绑定response响应宏"><a href="#在boot绑定response响应宏" class="headerlink" title="在boot绑定response响应宏"></a>在boot绑定response响应宏</h2><p>这一步主要就是给自带的response方法添加一些自己的方法：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716220732.png" alt=""></p><pre><code class="php">use Illuminate\Support\Facades\Response;Response::macro(&#39;success&#39;, function ($code = 200, $msg = &#39;success&#39;, $data = &#39;&#39;,$status = 200) {    $content = array(&#39;code&#39; =&gt; $code, &#39;msg&#39; =&gt; $msg, &#39;data&#39; =&gt; $data);    return response()-&gt;json($content,$status);});Response::macro(&#39;fail&#39;, function ($code = 100, $msg = &#39;fail&#39;, $data = &#39;&#39;,$status = 200) {    $content = array(&#39;code&#39; =&gt; $code, &#39;msg&#39; =&gt; $msg, &#39;data&#39; =&gt; $data);    return response()-&gt;json($content,$status);});</code></pre><h2 id="在config-app-php文件中注册"><a href="#在config-app-php文件中注册" class="headerlink" title="在config/app.php文件中注册"></a>在config/app.php文件中注册</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716220817.png" alt=""></p><h2 id="控制器中的使用"><a href="#控制器中的使用" class="headerlink" title="控制器中的使用"></a>控制器中的使用</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716220846.png" alt=""></p><h1 id="composer全局绑定"><a href="#composer全局绑定" class="headerlink" title="composer全局绑定"></a>composer全局绑定</h1><h2 id="定义返回函数"><a href="#定义返回函数" class="headerlink" title="定义返回函数"></a>定义返回函数</h2><p>新建一个文件：json.php（这里的publicEncrypt是我进行数据加密的方法，你们直接删除掉就行）</p><pre><code class="php">if (!function_exists(&#39;json_response&#39;)) {    /**     * 返回给页面json的信息，ajax操作时返回的提示信息     * @param $code     * @param $msg     * @param null $data     * @param int $status     * @return \Illuminate\Http\JsonResponse     */    function json_response($code, $msg, $data = null, $status = 200)    {        return response()-&gt;json(array(&#39;code&#39; =&gt; $code, &#39;msg&#39; =&gt; $msg, &#39;data&#39; =&gt; $data == null ? null : publicEncrypt($data)), $status);    }}if (!function_exists(&#39;json_success&#39;)) {    function json_success($msg = &#39;操作成功!&#39;, $data = null)    {        return json_response(0, $msg, $data);    }}if (!function_exists(&#39;json_fail&#39;)) {    function json_fail($msg = &#39;操作失败!&#39;, $data = null)    {        return json_response(1, $msg, $data);    }}</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716221718.png" alt=""></p><p>新建funtions.php（因为我这里还导入了其他的函数所以就有下面很多，主要的还是导入我们上面写的文件）</p><pre><code class="php">/* 引入json相关辅助函数 */require_once &quot;json.php&quot;;</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716221853.png" alt=""></p><h2 id="composer全局导入"><a href="#composer全局导入" class="headerlink" title="composer全局导入"></a>composer全局导入</h2><p>打开composer.json文件,添加我们的funtions.php</p><pre><code class="json">&quot;files&quot;: [    &quot;app/Helpers/functions.php&quot; //你的functions文件路径]</code></pre><p>然后只需要重新composer 更新一下就行：</p><pre><code class="php">composer update</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>控制器中的使用：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/16/20200716222336.png" alt=""></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> php </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
