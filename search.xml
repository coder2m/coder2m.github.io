<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang邮件发送</title>
      <link href="/posts/golang/4db013d1.html"/>
      <url>/posts/golang/4db013d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><pre><code class="golang">go get github.com/jordan-wright/email</code></pre><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;net/smtp&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    e := email.NewEmail()    //设置发送方的邮箱    e.From = &quot;112233 &lt;XXX@qq.com&gt;&quot;    // 设置接收方的邮箱    e.To = []string{&quot;XXX@qq.com&quot;}    //设置主题    e.Subject = &quot;这是主题&quot;    //设置文件发送的内容    e.Text = []byte(&quot;发送的内容&quot;)    //设置服务器相关的配置    err := e.Send(&quot;smtp.qq.com:25&quot;, smtp.PlainAuth(&quot;&quot;, &quot;你的邮箱账号&quot;, &quot;这块是你的授权码&quot;, &quot;smtp.qq.com&quot;))    if err != nil {       ....    }}</code></pre><h2 id="实现抄送功能"><a href="#实现抄送功能" class="headerlink" title="实现抄送功能"></a>实现抄送功能</h2><pre><code class="golang">func main() {    ...    //设置抄送如果抄送多人逗号隔开    e.Cc = []string{&quot;XXX@qq.com&quot;,XXX@qq.com}    //设置秘密抄送    e.Bcc = []string{&quot;XXX@qq.com&quot;}    ...}</code></pre><h2 id="发送html代码的邮件"><a href="#发送html代码的邮件" class="headerlink" title="发送html代码的邮件"></a>发送html代码的邮件</h2><pre><code class="golang">func main() {    ...    e.HTML = []byte(`    &lt;h1&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/h1&gt;        `)    ...}</code></pre><h2 id="实现邮件附件的发送"><a href="#实现邮件附件的发送" class="headerlink" title="实现邮件附件的发送"></a>实现邮件附件的发送</h2><pre><code class="golang">func main() {    ...    e.AttachFile(&quot;./test.txt&quot;)    ...}</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>每次调用Send时都会和 SMTP 服务器建立一次连接，如果发送邮件很多很频繁的话可能会有性能问题。email提供了连接池，可以复用网络连接：</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net/smtp&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    ch := make(chan *email.Email, 10)    p, err := email.NewPool(        &quot;smtp.qq.com:25&quot;,        4,        smtp.PlainAuth(&quot;&quot;, &quot;XXX@qq.com&quot;, &quot;你的授权码&quot;, &quot;smtp.qq.com&quot;),    )    if err != nil {        log.Fatal(&quot;failed to create pool:&quot;, err)    }    var wg sync.WaitGroup    wg.Add(4)    for i := 0; i &lt; 4; i++ {        go func() {            defer wg.Done()            for e := range ch {                err := p.Send(e, 10*time.Second)                if err != nil {                    fmt.Fprintf(os.Stderr, &quot;email:%v sent error:%v\n&quot;, e, err)                }            }        }()    }    for i := 0; i &lt; 10; i++ {        e := email.NewEmail()        e.From = &quot;dj &lt;XXX@qq.com&gt;&quot;        e.To = []string{&quot;XXX@qq.com&quot;}        e.Subject = &quot;Awesome web&quot;        e.Text = []byte(fmt.Sprintf(&quot;Awesome Web %d&quot;, i+1))        ch &lt;- e    }    close(ch)    wg.Wait()}</code></pre><p>上面程序中，我们创建 4 goroutine 共用一个连接池发送邮件，发送 10 封邮件后程序退出。为了等邮件都发送完成或失败，程序才退出，我们使用了sync.WaitGroup。由于使用了 goroutine，邮件顺序不能保证。</p><p>参考连接：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/posts/jenkins/87b776c7.html"/>
      <url>/posts/jenkins/87b776c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json   #这个Json文件与上边的配置文件是相同的</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出 </p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/posts/golang/41aae1e1.html"/>
      <url>/posts/golang/41aae1e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>    自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
