<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Golang-Redis简易封装</title>
      <link href="/posts/golang/b9458491.html"/>
      <url>/posts/golang/b9458491.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang-Redis"><a href="#Golang-Redis" class="headerlink" title="Golang Redis"></a>Golang Redis</h1><h2 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h2><pre><code class="golang">go get github.com/gomodule/redigo</code></pre><h2 id="Redis-操作封装"><a href="#Redis-操作封装" class="headerlink" title="Redis 操作封装"></a>Redis 操作封装</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="ini">[redis]Host = 127.0.0.1:6379Password =MaxIdle = 30MaxActive = 30IdleTimeout = 200</code></pre><h3 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h3><pre><code class="golang">package Redisimport (    &quot;encoding/json&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;github.com/gomodule/redigo/redis&quot;)//定义redis连接池var Conn *redis.Pool//初始化func InitRedis() error {    Conn = &amp;redis.Pool{        MaxIdle:     Config.RedisSetting.MaxIdle,        MaxActive:   Config.RedisSetting.MaxActive,        IdleTimeout: Config.RedisSetting.IdleTimeout,        Dial: func() (redis.Conn, error) {            c, err := redis.Dial(&quot;tcp&quot;, Config.RedisSetting.Host)            if err != nil {                return nil, err            }            if Config.RedisSetting.Password != &quot;&quot; {                if _, err := c.Do(&quot;AUTH&quot;, Config.RedisSetting.Password); err != nil {                    _ = c.Close()                    return nil, err                }            }            return c, err        },        TestOnBorrow: func(c redis.Conn, t time.Time) error {            _, err := c.Do(&quot;PING&quot;)            return err        },    }    return nil}//redis 设置函数func Set(key string, data interface{}, time int) (bool, error) {    conn := Conn.Get()    defer conn.Close()    value, err := json.Marshal(data)    if err != nil {        return false, err    }    reply, err := redis.String(conn.Do(&quot;SET&quot;, key, value))    _, _ = conn.Do(&quot;EXPIRE&quot;, key, time)    return reply == &quot;OK&quot;, err}//redis 检测存在函数func Exists(key string) bool {    conn := Conn.Get()    defer conn.Close()    exists, err := redis.Bool(conn.Do(&quot;EXISTS&quot;, key))    if err != nil {        return false    }    return exists}//redis 获取函数func Get(key string) ([]byte, error) {    conn := Conn.Get()    defer conn.Close()    reply, err := redis.Bytes(conn.Do(&quot;GET&quot;, key))    if err != nil {        return nil, err    }    return reply, nil}//redis 删除函数func Delete(key string) (bool, error) {    conn := Conn.Get()    defer conn.Close()    return redis.Bool(conn.Do(&quot;DEL&quot;, key))}//redis 模糊删除函数func LikeDeletes(key string) error {    conn := Conn.Get()    defer conn.Close()    keys, err := redis.Strings(conn.Do(&quot;KEYS&quot;, &quot;*&quot;+key+&quot;*&quot;))    if err != nil {        return err    }    for _, key := range keys {        _, err = Delete(key)        if err != nil {            return err        }    }    return nil}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="golang">if err := Redis.InitRedis(); err != nil {    log.Println(&quot;init redis failed, err:&quot; + err.Error())    return}</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code class="golang">...if Redis.Exists(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...if Redis.Get(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...</code></pre><p>使用很简单这里就不一一举例了。通过这样的封装redis操作就变得更加简单了。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang使用jwt</title>
      <link href="/posts/golang/631d0e90.html"/>
      <url>/posts/golang/631d0e90.html</url>
      
        <content type="html"><![CDATA[<h1 id="Golang中使用JWT-json-web-token"><a href="#Golang中使用JWT-json-web-token" class="headerlink" title="Golang中使用JWT(json web token)"></a>Golang中使用JWT(json web token)</h1><h2 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h2><p>什么是jwt这里就不多说了，官网有介绍。官网介绍：<a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h3><pre><code class="golang">go get -u github.com/dgrijalva/jwt-go</code></pre><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="ini">[jwt]# 盐JwtSecret = jdnsakjbduiiudu# 过期时间（天ExpiresAt = 3# 签发Issuer = jwt</code></pre><h4 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h4><pre><code class="golang">package Utilsimport (    &quot;errors&quot;    &quot;github.com/dgrijalva/jwt-go&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;wPan/v1/Models&quot; //加载模型)// JWT 签名结构type JWT struct {    SigningKey []byte}//JWT 中存储得数据结构体 这里可以根据需求自由添加type UserInfo struct {    Id       int    `json:&quot;id&quot;`    Username string `json:&quot;username&quot;`    Email    string `json:&quot;email&quot;`    Status   int    `json:&quot;status&quot;`}// 生成JWT函数func GenerateToken(user *Models.User) (string, error) {    claim := jwt.MapClaims{        //这里为自定义        &quot;username&quot;: user.UserName,        &quot;id&quot;:       user.ID,        &quot;email&quot;:    user.Email,        &quot;status&quot;:   user.Status,        //到这里，后面都是必须的        &quot;nbf&quot;: time.Now().Unix(),        &quot;iat&quot;: time.Now().Unix(),        //设置过期时间        &quot;exp&quot;: time.Now().Unix() + Config.JWTSetting.ExpiresAt*60*60,        //签名方        &quot;iss&quot;: Config.JWTSetting.Issuer,    }    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)    tokens, err := token.SignedString([]byte(Config.JWTSetting.JwtSecret))    return tokens, err}//设置盐func secret() jwt.Keyfunc {    return func(token *jwt.Token) (interface{}, error) {        return []byte(Config.JWTSetting.JwtSecret), nil    }}//token 验证func ParseToken(tokens string) (user *UserInfo, err error) {    user = &amp;UserInfo{}    token, err := jwt.Parse(tokens, secret())    if err != nil {        return    }    claim, ok := token.Claims.(jwt.MapClaims)    if !ok {        err = errors.New(&quot;cannot convert claim to mapclaim&quot;)        return    }    //验证token，如果token被修改过则为false    if !token.Valid {        err = errors.New(&quot;token is invalid&quot;)        return    }    //提取当初我们生成时候存储的数据    user.Id = int(claim[&quot;id&quot;].(float64))    user.Username = claim[&quot;username&quot;].(string)    user.Email = claim[&quot;email&quot;].(string)    user.Status = int(claim[&quot;status&quot;].(float64))    return}</code></pre><p>Service中的使用</p><pre><code class="golang">func GetJwt(u *Models.User) (string, bool) {    token, err := Utils.GenerateToken(u)    if err != nil {        return &quot;&quot;, false    }    return token, true}</code></pre><h4 id="编写验证中间件"><a href="#编写验证中间件" class="headerlink" title="编写验证中间件"></a>编写验证中间件</h4><p>我这里使用的gin框架，其他的框架也类似</p><pre><code class="golang">func Auth() gin.HandlerFunc {    return func(c *gin.Context) {        token := c.GetHeader(&quot;Authorization&quot;)        userInfo, err := Utils.ParseToken(token[7:])        if err != nil {            R.Response(c, http.StatusUnauthorized, R.AUTH_ERROR, nil, http.StatusUnauthorized)            c.Abort()            return        }        c.Set(&quot;userInfo&quot;, userInfo)        c.Next()        return    }}</code></pre><h4 id="路由中使用"><a href="#路由中使用" class="headerlink" title="路由中使用"></a>路由中使用</h4><pre><code class="golang">authApi.GET(&quot;/info&quot;, Middleware.Auth(), Controllers.Info)</code></pre><p>这样用户再访问需要验证的请求时，就需要请求头中带上<code>Authorization</code>，value为token。</p><p>参考连接：<a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">https://github.com/dgrijalva/jwt-go</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang邮件发送</title>
      <link href="/posts/golang/4db013d1.html"/>
      <url>/posts/golang/4db013d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><pre><code class="golang">go get github.com/jordan-wright/email</code></pre><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;net/smtp&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    e := email.NewEmail()    //设置发送方的邮箱    e.From = &quot;112233 &lt;XXX@qq.com&gt;&quot;    // 设置接收方的邮箱    e.To = []string{&quot;XXX@qq.com&quot;}    //设置主题    e.Subject = &quot;这是主题&quot;    //设置文件发送的内容    e.Text = []byte(&quot;发送的内容&quot;)    //设置服务器相关的配置    err := e.Send(&quot;smtp.qq.com:25&quot;, smtp.PlainAuth(&quot;&quot;, &quot;你的邮箱账号&quot;, &quot;这块是你的授权码&quot;, &quot;smtp.qq.com&quot;))    if err != nil {       ....    }}</code></pre><h2 id="实现抄送功能"><a href="#实现抄送功能" class="headerlink" title="实现抄送功能"></a>实现抄送功能</h2><pre><code class="golang">func main() {    ...    //设置抄送如果抄送多人逗号隔开    e.Cc = []string{&quot;XXX@qq.com&quot;,XXX@qq.com}    //设置秘密抄送    e.Bcc = []string{&quot;XXX@qq.com&quot;}    ...}</code></pre><h2 id="发送html代码的邮件"><a href="#发送html代码的邮件" class="headerlink" title="发送html代码的邮件"></a>发送html代码的邮件</h2><pre><code class="golang">func main() {    ...    e.HTML = []byte(`    &lt;h1&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/h1&gt;        `)    ...}</code></pre><h2 id="实现邮件附件的发送"><a href="#实现邮件附件的发送" class="headerlink" title="实现邮件附件的发送"></a>实现邮件附件的发送</h2><pre><code class="golang">func main() {    ...    e.AttachFile(&quot;./test.txt&quot;)    ...}</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>每次调用Send时都会和 SMTP 服务器建立一次连接，如果发送邮件很多很频繁的话可能会有性能问题。email提供了连接池，可以复用网络连接：</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net/smtp&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    ch := make(chan *email.Email, 10)    p, err := email.NewPool(        &quot;smtp.qq.com:25&quot;,        4,        smtp.PlainAuth(&quot;&quot;, &quot;XXX@qq.com&quot;, &quot;你的授权码&quot;, &quot;smtp.qq.com&quot;),    )    if err != nil {        log.Fatal(&quot;failed to create pool:&quot;, err)    }    var wg sync.WaitGroup    wg.Add(4)    for i := 0; i &lt; 4; i++ {        go func() {            defer wg.Done()            for e := range ch {                err := p.Send(e, 10*time.Second)                if err != nil {                    fmt.Fprintf(os.Stderr, &quot;email:%v sent error:%v\n&quot;, e, err)                }            }        }()    }    for i := 0; i &lt; 10; i++ {        e := email.NewEmail()        e.From = &quot;dj &lt;XXX@qq.com&gt;&quot;        e.To = []string{&quot;XXX@qq.com&quot;}        e.Subject = &quot;Awesome web&quot;        e.Text = []byte(fmt.Sprintf(&quot;Awesome Web %d&quot;, i+1))        ch &lt;- e    }    close(ch)    wg.Wait()}</code></pre><p>上面程序中，我们创建 4 goroutine 共用一个连接池发送邮件，发送 10 封邮件后程序退出。为了等邮件都发送完成或失败，程序才退出，我们使用了sync.WaitGroup。由于使用了 goroutine，邮件顺序不能保证。</p><p>参考连接：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/posts/jenkins/87b776c7.html"/>
      <url>/posts/jenkins/87b776c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json   #这个Json文件与上边的配置文件是相同的</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出 </p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/posts/golang/41aae1e1.html"/>
      <url>/posts/golang/41aae1e1.html</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>    自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre><p>参考连接：<a href="https://www.cnblogs.com/blogbobo/p/13169714.html" target="_blank" rel="noopener">https://www.cnblogs.com/blogbobo/p/13169714.html</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
