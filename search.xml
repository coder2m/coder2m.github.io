<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Protobuf通信协议</title>
      <link href="/posts/golang/ac0a6a86.html"/>
      <url>/posts/golang/ac0a6a86.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 20:39:53 GMT+0800 (GMT+08:00) --><h1 id="RPC的调用过程"><a href="#RPC的调用过程" class="headerlink" title="RPC的调用过程"></a>RPC的调用过程</h1><p>一个正常的RPC过程可以分为一下几个步骤：</p><ul><li>client调用client stub，这是一次本地过程调用。</li><li>client stub将参数打包成一个消息，然后发送这个消息。打包过程也叫做marshalling。</li><li>client所在的系统将消息发送给server。</li><li>server的的系统将收到的包传给server stub。</li><li>server stub解包得到参数。 解包也被称作 unmarshalling。</li><li>server stub调用服务过程。返回结果按照相反的步骤传给client。</li></ul><p>在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</p><ul><li>1、Call ID映射。远端进程中间可以包含定义的多个函数，本地客户端该如何告知远端进程程序调用特定的某个函数呢？因此，在RPC调用过程中，所有的函数都需要有一个自己的ID。开发者在客户端（调用端）和服务端（被调用端）分别维护一个{函数&lt;–&gt;Call ID}的对应表。两者的表不一定完全相同，但是相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，调用者通过映射表查询想要调用的函数的名称，找到对应的Call ID，然后传递给服务端，服务端也通过查表，来确定客户端所需要调用的函数，然后执行相应函数的代码。</li><li>2、序列化与反序列化。客户端如何把参数传递给远程调用的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</li><li>3、网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传递给服务端，然后在把序列化后的调用结果传回给客户端，完成这种数据传递功能的被成为传输层。大部分的网络传输成都使用TCP协议，属于长连接。</li></ul><p>有对传递的数据进行序列化和反序列化的操作，这就是我们这里要说的：Protobuf。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Google Protocol Buffer( 简称 Protobuf)是Google公司内部的混合语言数据标准，他们主要用于RPC系统和持续数据存储系统。</p><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或RPC数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。简单来说，Protobuf的功能类似于XML，即负责把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议等使用场景。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装protobuf编译器"><a href="#安装protobuf编译器" class="headerlink" title="安装protobuf编译器"></a>安装protobuf编译器</h2><p>可以在如下地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a>选择适合自己系统的Proto编译器程序进行下载并解压。然后配置环境变量：将protocke执行文件所在目录添加到当前系统的环境变量中。windows系统下可以直接在Path目录中进行添加。</p><h2 id="安装go依赖"><a href="#安装go依赖" class="headerlink" title="安装go依赖"></a>安装go依赖</h2><pre><code class="golang">go get github.com/golang/protobuf/protoc-gen-go</code></pre><h1 id="Protobuf-协议语法"><a href="#Protobuf-协议语法" class="headerlink" title="Protobuf 协议语法"></a>Protobuf 协议语法</h1><h2 id="message："><a href="#message：" class="headerlink" title="message："></a>message：</h2><p>Protobuf中定义一个数据结构需要用到关键字message，这一点和Java的class，Go语言中的struct类似。</p><h2 id="标识号："><a href="#标识号：" class="headerlink" title="标识号："></a>标识号：</h2><p>在消息的定义中，每个字段等号后面都有唯一的标识号，用于在反序列化过程中识别各个字段的，一旦开始使用就不能改变。标识号从整数1开始，依次递增，每次增加1，标识号的范围为1~2^29 – 1，其中[19000-19999]为Protobuf协议预留字段，开发者不建议使用该范围的标识号；一旦使用，在编译时Protoc编译器会报出警告。</p><h2 id="字段规则："><a href="#字段规则：" class="headerlink" title="字段规则："></a>字段规则：</h2><p>字段规则有三种：</p><ul><li>1.required：该规则规定，消息体中该字段的值是必须要设置的。</li><li>2.optional：消息体中该规则的字段的值可以存在，也可以为空，optional的字段可以根据defalut设置默认值。</li><li>3.repeated：消息体中该规则字段可以存在多个（包括0个），该规则对应java的数组或者go语言的slice。</li></ul><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><p>常见的数据类型与protoc协议中的数据类型映射如下：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712161553.png" alt=""></p><h2 id="枚举类型："><a href="#枚举类型：" class="headerlink" title="枚举类型："></a>枚举类型：</h2><p>proto协议支持使用枚举类型</p><pre><code class="golang">enum Sex{    male=1;    female=2;}</code></pre><h2 id="字段默认值："><a href="#字段默认值：" class="headerlink" title="字段默认值："></a>字段默认值：</h2><pre><code class="golang">message Address {    required sint32 id = 1 [default = 1];    required string name = 2 [default = &#39;北京&#39;];    optional string pinyin = 3 [default = &#39;beijing&#39;];    required string address = 4;    required bool flag = 5 [default = true];}</code></pre><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>如果需要引用的message是写在别的.proto文件中，可以通过import “xxx.proto”来进行引入</p><h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><pre><code class="golang">syntax = &quot;proto3&quot;;package example;message Person {    required string Name = 1;    required int32 Age = 2;    required string From = 3;    optional Address Addr = 4;    message Address {        required sint32 id = 1;        required string name = 2;        optional string pinyin = 3;        required string address = 4;    }}</code></pre><h1 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h1><p>这里看你，需要使用什么语言的，如果你需要再c和py之间传输数据，你就需要生成对应的c和py文件，就行。这里我因为使用的golang。我就生成go的</p><pre><code class="golang">protoc --go_out=. *.proto</code></pre><h2 id="这里推荐下几个插件（golang）"><a href="#这里推荐下几个插件（golang）" class="headerlink" title="这里推荐下几个插件（golang）"></a>这里推荐下几个插件（golang）</h2><ul><li><p>protoc-gen-gogo：和protoc-gen-go生成的文件差不多，性能也几乎一样(稍微快一点点)</p></li><li><p>protoc-gen-gofast：生成的文件更复杂，性能也更高(快5-7倍)</p></li></ul><pre><code class="golang">//gogogo get github.com/gogo/protobuf/protoc-gen-gogo//gofastgo get github.com/gogo/protobuf/protoc-gen-gofast</code></pre><p>安装gogoprotobuf库文件</p><pre><code class="golang">go get github.com/gogo/protobuf/protogo get github.com/gogo/protobuf/gogoproto  //这个不装也没关系</code></pre><p>生成文件</p><pre><code class="golang">//gogoprotoc --gogo_out=. *.proto//gofastprotoc --gofast_out=. *.proto</code></pre><p>性能测试</p><pre><code class="golang">//goprotobuf&quot;编码&quot;：447ns/op&quot;解码&quot;：422ns/op//gogoprotobuf-go&quot;编码&quot;：433ns/op&quot;解码&quot;：427ns/op//gogoprotobuf-fast&quot;编码&quot;：112ns/op&quot;解码&quot;：112ns/op</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>把消息进行编码</p><pre><code class="golang">book := &amp;pb.AddressBook{}// ...out, err := proto.Marshal(book)if err != nil {        log.Fatalln(&quot;Failed to encode address book:&quot;, err)}if err := ioutil.WriteFile(fname, out, 0644); err != nil {        log.Fatalln(&quot;Failed to write address book:&quot;, err)}</code></pre><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>把消息进行解码</p><pre><code class="golang">in, err := ioutil.ReadFile(fname)if err != nil {        log.Fatalln(&quot;Error reading file:&quot;, err)}book := &amp;pb.AddressBook{}if err := proto.Unmarshal(in, book); err != nil {        log.Fatalln(&quot;Failed to parse address book:&quot;, err)}</code></pre><p>参考连接：<a href="https://developers.google.com/protocol-buffers/docs/gotutorial" target="_blank" rel="noopener">https://developers.google.com/protocol-buffers/docs/gotutorial</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
            <tag> rpc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang开发分布式电商网站高并发秒杀系统</title>
      <link href="/posts/golang/6edb5861.html"/>
      <url>/posts/golang/6edb5861.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 13:21:49 GMT+0800 (GMT+08:00) --><blockquote><p>这个系统的主要目的在于秒杀，所有其他地方都做的很简单。基础功能不多！</p></blockquote><h1 id="技术栈："><a href="#技术栈：" class="headerlink" title="技术栈："></a>技术栈：</h1><blockquote><p>web框架：gin</p></blockquote><blockquote><p>消息队列：RabbitMQ</p></blockquote><blockquote><p>分布式方案：hash环</p></blockquote><blockquote><p>orm: gorm</p></blockquote><blockquote><p>限流器：tollbooth</p></blockquote><blockquote><p>登录验证：jwt</p></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构:"></a>架构:</h1><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712131203.png" alt=""></p><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>cd /cmd</p><p>go run main.go //启动后台管理接口</p><p>go run client.go //启动RabbitMQ写入数据库客户端</p><p>go run spike.go //启动秒杀系统，支持横行扩展</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试没有使用集群，只是一个服务器</p><p>这里我使用测试工具是jmeter</p><h2 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090309.png" alt=""></p><h2 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712085943.png" alt=""></p><h2 id="RabbitMQ："><a href="#RabbitMQ：" class="headerlink" title="RabbitMQ："></a>RabbitMQ：</h2><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090446.png" alt=""></p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql:"></a>mysql:</h2><p>并没有超卖，测试添加了1000个库存</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090604.png" alt=""></p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/12/20200712090629.png" alt=""></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>这里主要说下最重要的秒杀流程。主要的核心逻辑在<code>spike_service.go</code>中。</p><p>项目在启动的时候，我们查询一下数据库，对数据库中需要秒杀的商品的信息，缓存到程序中，再后面的秒杀请求中，对其缓存进行修改，这样就实现了去redis实现。</p><p>具体的代码：</p><pre><code class="golang">    //记录现在的秒杀商品的数量    commodityCache map[int]*models.Commodity    models.Init()    models.MysqlHandler.AutoMigrate(models.Order{})    repository := &amp;repositories.CommodityRepository{Db: models.MysqlHandler}    service := &amp;services.CommodityService{CommodityRepository: repository}    commodityList, err := service.GetCommodityAll()      for _, value := range *commodityList {        commodityCache[int(value.ID)] = &amp;value  }</code></pre><p>这样缓存到了程序中，后面的判断都再这个程序缓存中，速度就快很多。但是这也有个缺点，当你的秒杀商品很多的时候，可能导致你的程序内存使用很高。这里要注意的是，修改缓存数据的时候，记得加锁。</p><p>然后后面的具体操作就是通过一致性hash算法，进行选择服务器，如果计算出来的就是本机就本机进行操作，如果是其他ip就本机使用代理访问，这样就实现了分布式操作。</p><p>设计的东西还是比较多。直接看看源代码，应该还是能看懂。我项目的写的还是比较清楚的。感兴趣的可以看看。</p><p>项目github地址：<a href="https://github.com/myxy99/shopping" target="_blank" rel="noopener">https://github.com/myxy99/shopping</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang中的ORM-Gorm的关联模型</title>
      <link href="/posts/golang/54a7f546.html"/>
      <url>/posts/golang/54a7f546.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sat Jul 11 2020 14:09:24 GMT+0800 (GMT+08:00) --><h1 id="Golang中的ORM-Gorm的关联模型"><a href="#Golang中的ORM-Gorm的关联模型" class="headerlink" title="Golang中的ORM-Gorm的关联模型"></a>Golang中的ORM-Gorm的关联模型</h1><p>对于gorm的基础CRUD用法，这里就不论述了，这里主要说下关联模型的问题，因为我自己在查看官方文档进行关联模型操作的时候，总是感觉官方的例子很奇怪，用着很不明白。对于gorm的基础CRUD用法，不明白的可以看看官方文档：<a href="https://gorm.io/zh_CN/docs/models.html" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/models.html</a></p><h1 id="创建数据库层面的外键："><a href="#创建数据库层面的外键：" class="headerlink" title="创建数据库层面的外键："></a>创建数据库层面的外键：</h1><pre><code class="golang">models.MysqlHandler.Model(&amp;models.Order{}).AddForeignKey(&quot;user_id&quot;, &quot;user(id)&quot;, &quot;RESTRICT&quot;, &quot;RESTRICT&quot;)</code></pre><p>说说这里的RESTRICT，这里还可以填CASCADE、NO ACTION、RESTRICT、SET NULL。分别的意思是：</p><blockquote><p>CASCADE：父表delete、update的时候，子表会delete、update掉关联记录；</p><p>SET NULL：父表delete、update的时候，子表会将关联记录的外键字段所在列设为null，所以注意在设计子表时外键不能设为not null；</p><p>RESTRICT：如果想要删除父表的记录时，而在子表中有关联该父表的记录，则不允许删除父表中的记录；</p><p>NO ACTION：同 RESTRICT，也是首先先检查外键；</p></blockquote><h1 id="Belongs-To"><a href="#Belongs-To" class="headerlink" title="Belongs To"></a>Belongs To</h1><p>belongs to 关联建立一个和另一个模型的一对一连接，使得模型声明每个实例都<code>属于</code>另一个模型的一个实例 。</p><h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><p>例如，如果你的应用包含了用户和用户所属部门， 并且每一个用户所属只分配给一个用户。模型定义：</p><pre><code class="golang">type User struct {    gorm.Model    Name string}// `Department` 属于 `User`， 外键是`UserID`type Department struct {    gorm.Model    UserID uint    User   User    Name   string}</code></pre><p>生成的表结构：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/blog/2020/07/11/20200711101256.png" alt=""></p><h2 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h2><p>默认的外键使用所有者类型名称加上其主键。像上面的例子，为了声明一个模型属于 User，它的外键应该为 UserID。</p><p>GORM 提供了一个定制外键的方法，例如:</p><pre><code class="golang">type User struct {    gorm.Model    Name string}type Department struct {  gorm.Model  Name      string  User      User `gorm:&quot;foreignkey:UserDepartment&quot;` // 使用 UserRefer 作为外键  UserDepartment uint}</code></pre><blockquote><p>后面其他连接方式也一样</p></blockquote><h2 id="关联外键"><a href="#关联外键" class="headerlink" title="关联外键"></a>关联外键</h2><p>GORM 默认使用所有者的主键作为外键值，在上面的例子中，就是 User 的 ID。当你分配一个资料给一个用户， GORM 将保存用户表的 ID 值 到 用户资料表的 UserID 字段里。你可以通过改变标签 association_foreignkey 外键值：</p><pre><code class="golang">type User struct {    gorm.Model    Department uint    Name string}type Department struct {  gorm.Model  Name      string  User      User `gorm:&quot;association_foreignkey:Refer&quot;` // use Department 作为关联外键  UserDepartment uint}</code></pre><blockquote><p>后面其他连接方式也一样</p></blockquote><h2 id="Belongs-To-的使用"><a href="#Belongs-To-的使用" class="headerlink" title="Belongs To 的使用"></a>Belongs To 的使用</h2><p>这里就是重点了，这里我直接放代码：</p><pre><code class="golang">type User struct {    gorm.Model    Name string}// `Department` 属于 `User`， 外键是`UserID`type Department struct {    gorm.Model    UserID uint    User   User    Name   string}//这里的MysqlHandler就是gorm中的数据库操作DBfunc TestGormBelongsTo(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(User{})    MysqlHandler.AutoMigrate(Department{})    //链表添加数据    //profile := Profile{    //    User: User{    //        Name: &quot;张三&quot;,    //    },    //    Name: &quot;项目组&quot;,    //}    //MysqlHandler.Create(&amp;profile)    //链表查询    //var infoList []Department    //var user User    //MysqlHandler.Preload(&quot;User&quot;).Find(&amp;infoList)    //for _, value := range infoList {    //    fmt.Println(value.Name)    //    fmt.Println(value.User.Name)    //}    // 查询添加条件 这里的条件就是 Department id为2 对应的数据    //var info Department    //info.ID = 2    //MysqlHandler.Debug().Preload(&quot;User&quot;).Find(&amp;info)    //fmt.Println(info.Name, info.User.Name)    //USER name为张三A 对应的数据    //var info Department    //MysqlHandler.Debug().Preload(&quot;User&quot;, func(query *gorm.DB) *gorm.DB {    //    return query.Where(&quot;name =? &quot;, &quot;张三A&quot;)    //}).First(&amp;info)    //fmt.Println(info.Name, info.User.Name, info.User.ID)    //    or    //var infoList []Department    //MysqlHandler.Debug().Preload(&quot;User&quot;, &quot;name =?&quot;,&quot;张三A&quot;).First(&amp;infoList)    //for _, value := range infoList {    //    fmt.Println(value.Name, value.User.Name, value.User.ID)    //}    // 使用 Related 查找 belongs to 关系    var department Department               //需要查找总的结构体    department.ID = 3                       //定义查询条件    MysqlHandler.Debug().First(&amp;department) //首先查询总表    /// SELECT * FROM `department`  WHERE `department`.`deleted_at` IS NULL AND `department`.`id` = 3 ORDER BY `department`.`id` ASC LIMIT 1    MysqlHandler.Debug().Model(&amp;department).Related(&amp;department.User) //查询子表进行赋值    /// SELECT * FROM `user`  WHERE `user`.`deleted_at` IS NULL AND ((`id` = 2))    fmt.Println(department.Name, &quot;---&quot;, department.User.Name, &quot;---&quot;, department.ID, &quot;---&quot;, department.User.ID)}</code></pre><p>由于gorm支持链式操作，后续需要什么操作 再往上加就行。</p><h1 id="Has-One"><a href="#Has-One" class="headerlink" title="Has One"></a>Has One</h1><h2 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h2><pre><code class="golang">//车type Car struct {    gorm.Model    Host         string //车主人名字    LicensePlate LicensePlate}//车牌type LicensePlate struct {    gorm.Model    Number string //车牌号    CarID  uint}</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>Has One的操作很Belongs To相同，可以自己实操一下。就明白了。</p><h1 id="Belongs-To跟Has-One的区别"><a href="#Belongs-To跟Has-One的区别" class="headerlink" title="Belongs To跟Has One的区别"></a>Belongs To跟Has One的区别</h1><p>同样是一对一 Belongs To跟Has One的区别是什么呢？从两个结构体不难看出差别。区别： 外键属性存在位置不同，foreignKey 指定源不同，targetKey 指定源不同</p><h1 id="Has-Many"><a href="#Has-Many" class="headerlink" title="Has Many"></a>Has Many</h1><p>has many 关联就是创建和另一个模型的一对多关系， 不像 has one，所有者可以拥有0个或多个模型实例。</p><h2 id="定义模型-2"><a href="#定义模型-2" class="headerlink" title="定义模型"></a>定义模型</h2><p>如果你的业务数据库包含学校和专业， 并且每一个学校都拥有多门专业。</p><pre><code class="golang">//学校type School struct {    gorm.Model    Name       string    Profession []Profession}//专业type Profession struct {    gorm.Model    Name     string    SchoolId uint}</code></pre><h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><pre><code class="golang">func TestGormHasMany(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(School{})    MysqlHandler.AutoMigrate(Profession{})    //创建    //profession1 := Profession{Name: &quot;信息工程&quot;}    //profession2 := Profession{Name: &quot;计算机科学&quot;}    //var professionList []Profession    //professionList = append(professionList, profession1)    //professionList = append(professionList, profession2)    //school := School{    //    Name:       &quot;成都大学&quot;,    //    Profession: professionList,    //}    //MysqlHandler.Save(&amp;school) //or Create    //查询单列    //var school School    //MysqlHandler.Preload(&quot;Profession&quot;).First(&amp;school)    //fmt.Println(school)    //var school School    //MysqlHandler.First(&amp;school)    //MysqlHandler.Model(&amp;school).Related(&amp;school.Profession)    //fmt.Println(school)    //查询多列    var school []School    //MysqlHandler.First(&amp;school)    MysqlHandler.Model(&amp;school).Preload(&quot;Profession&quot;).Find(&amp;school)    for _, value := range school {        fmt.Println(value.Name, value.Profession)    }}</code></pre><h1 id="Many-To-Many"><a href="#Many-To-Many" class="headerlink" title="Many To Many"></a>Many To Many</h1><p>多对多为两个模型增加了一个中间表。</p><h2 id="定义模型-3"><a href="#定义模型-3" class="headerlink" title="定义模型"></a>定义模型</h2><p>例如，如果你的应用包含用户和语言， 一个用户会说多种语言，并且很多用户会说一种特定的语言。</p><pre><code class="golang">// 用户拥有并属于多种语言， 使用  `user_languages` 作为中间表type User struct {    gorm.Model    Languages         []Language `gorm:&quot;many2many:user_languages;&quot;`}type Language struct {    gorm.Model    Name string    Users               []User     `gorm:&quot;many2many:user_languages;&quot;`}</code></pre><h2 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h2><pre><code class="golang">func TestGormManyToMany(t *testing.T) {    MysqlHandler = mysqlBuild()    MysqlHandler.AutoMigrate(Users{})    MysqlHandler.AutoMigrate(Language{})    //    创建    //langEN := Language{Name: &quot;EN&quot;}    //langCN := Language{Name: &quot;CN&quot;}    //u1 := &amp;Users{    //    Name: &quot;user1&quot;,    //    Languages: []Language{    //        langEN,    //        langCN,    //    },    //}    //MysqlHandler.Create(u1)    //LangCN := Language{}    //MysqlHandler.Where(&quot;name=?&quot;,&quot;CN&quot;).First(&amp;LangCN)    //u2 := &amp;Users{    //    Name: &quot;user2&quot;,    //    Languages: []Language{    //        LangCN,    //    },    //}    //MysqlHandler.Create(u2)    //查询    //获取 用户id 为 3 的 user 的语言：    //var users Users    //MysqlHandler.Find(&amp;users, 3)    //MysqlHandler.Model(&amp;users).Related(&amp;users.Languages, &quot;Languages&quot;)    //查询    //获取 使用语言 为 CN 的 user：    //var language Language    //MysqlHandler.Find(&amp;language, &quot;name=?&quot;,&quot;CN&quot;)    //MysqlHandler.Model(&amp;language).Related(&amp;language.Users, &quot;Users&quot;)    //fmt.Println(language)}</code></pre><p>参考连接：<a href="https://gorm.io/zh_CN/docs/" target="_blank" rel="noopener">https://gorm.io/zh_CN/docs/</a></p><p>文章代码地址：<a href="https://github.com/myxy99/shopping/blob/master/test/gorm_test.go" target="_blank" rel="noopener">https://github.com/myxy99/shopping/blob/master/test/gorm_test.go</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> orm </tag>
            
            <tag> gorm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Protoc-go修改生成的文件的结构体的tag</title>
      <link href="/posts/golang/9e0030b.html"/>
      <url>/posts/golang/9e0030b.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 09:55:48 GMT+0800 (GMT+08:00) --><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在使用protoc生成的文件中生成的结构体的json没有小写，有时候我们就需要使用小写，最主要的就是在使用gin的时候还需要使用bind来绑定上传的东西。但是生成的*.pd.go又不建议我们去改。这时候就需要使用protoc-go-inject-tag，这里还有个更重要的地方，这里简单描述下：生成的结构体中的tag里面有个<code>omitempty</code>，这个的作用呢，就是在数据传输过程中，自动去掉<code>false 0 &quot;&quot;</code>这些数据。这里简单的举个例子，比如你的grpc服务端返回给客户端一个值为false的bool类型数据。但是在客户端接受的时候，这个字段就直接没有了。所以这样肯定是不行的。所以这里需要集体的去掉tag中的<code>omitempty</code>。这个时候protoc-go-inject-tag就可以满足这个需求。在之后的微服务（go-micro）开发中，这个也是很重要的地方！</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710092950.png" alt=""></p><p>git地址：<a href="https://github.com/favadi/protoc-go-inject-tag" target="_blank" rel="noopener">https://github.com/favadi/protoc-go-inject-tag</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="golang">go get github.com/favadi/protoc-go-inject-tag</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="只需要在-proto文件中写注释"><a href="#只需要在-proto文件中写注释" class="headerlink" title="只需要在.proto文件中写注释"></a>只需要在.proto文件中写注释</h2><pre><code class="proto">syntax = &quot;proto3&quot;;package study;//  请求参数message Token {    // @inject_tag: json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;    string jwtToken = 1; //1为字段顺序    // @inject_tag: json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;    int64 timeStamp = 2;}//  返回参数message TokenRequest {    // @inject_tag: json:&quot;isLogin&quot; form:&quot;isLogin&quot;    bool IsLogin = 1;}//  定义服务Auth//  服务方法CheckToken//  Token传入的值//  TokenRequest输出的值//  生成兼容grpc的go文件//  protoc --go_out=plugins=grpc:. *.protoservice Auth {    rpc CheckToken (Token) returns (TokenRequest);}</code></pre><h2 id="执行生成pb文件"><a href="#执行生成pb文件" class="headerlink" title="执行生成pb文件"></a>执行生成pb文件</h2><pre><code class="golang">protoc --go_out=plugins=grpc:. *.proto</code></pre><h2 id="执行修改tag-命令"><a href="#执行修改tag-命令" class="headerlink" title="执行修改tag 命令"></a>执行修改tag 命令</h2><pre><code class="golang">protoc-go-inject-tag -input=./*.pb.go</code></pre><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710095030.png" alt=""></p><h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>这个时候查看生成的文件就变成了这样</p><pre><code class="golang">//  请求参数type Token struct {    state         protoimpl.MessageState    sizeCache     protoimpl.SizeCache    unknownFields protoimpl.UnknownFields    // @inject_tag: json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;    JwtToken string `protobuf:&quot;bytes,1,opt,name=jwtToken,proto3&quot; json:&quot;jwtToken&quot; form:&quot;jwtToken&quot;` //1为字段顺序    // @inject_tag: json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;    TimeStamp int64 `protobuf:&quot;varint,2,opt,name=timeStamp,proto3&quot; json:&quot;timeStamp&quot; form:&quot;timeStamp&quot;`}//  返回参数type TokenRequest struct {    state         protoimpl.MessageState    sizeCache     protoimpl.SizeCache    unknownFields protoimpl.UnknownFields    // @inject_tag: json:&quot;isLogin&quot; form:&quot;isLogin&quot;    IsLogin bool `protobuf:&quot;varint,1,opt,name=IsLogin,proto3&quot; json:&quot;isLogin&quot; form:&quot;isLogin&quot;`}</code></pre><p>这样就行了，还可以根据自己的需求，自定义tag</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
            <tag> go-micro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang微服务开发-grpc</title>
      <link href="/posts/golang/5f3710bf.html"/>
      <url>/posts/golang/5f3710bf.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Fri Jul 10 2020 09:52:33 GMT+0800 (GMT+08:00) --><h1 id="什么是grpc"><a href="#什么是grpc" class="headerlink" title="什么是grpc"></a>什么是grpc</h1><p>grpc官网：<a href="https://www.grpc.io/" target="_blank" rel="noopener">https://www.grpc.io/</a></p><blockquote><p>A high-performance, open-source universal RPC framework</p></blockquote><p>这个是官方对他的解释。这里就出现了一个新的名称RPC。什么是RPC呢?RPC(remote procedure call 远程过程调用),所谓RPC框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server/client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</p><p>RPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082403.png" alt=""></p><p>RPC调用过程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082506.png" alt=""></p><p>GRPC结构图：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710082558.png" alt=""></p><p>性能对比可以查看这篇文章：<a href="https://blog.csdn.net/xuduorui/article/details/77938644" target="_blank" rel="noopener">https://blog.csdn.net/xuduorui/article/details/77938644</a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>先安装Protobuf 编译器 protoc，下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p><p>Protobuf插件库安装：</p><pre><code class="golang">// gRPC运行时接口编解码支持库go get -u github.com/golang/protobuf/proto// 从 Proto文件(gRPC接口描述文件) 生成 go文件 的编译器插件go get -u github.com/golang/protobuf/protoc-gen-go</code></pre><p>go依赖包</p><pre><code class="golang">go get -u google.golang.org/grpc</code></pre><h1 id="定义服务，编写proto文件"><a href="#定义服务，编写proto文件" class="headerlink" title="定义服务，编写proto文件"></a>定义服务，编写proto文件</h1><p>编写proto文件的语法什么的，我后面会单独出一篇文章。这里就不多说语法了。</p><pre><code class="proto">syntax = &quot;proto3&quot;;package study;//  请求参数message Token {    string jwtToken = 1; //1为字段顺序    int64 timeStamp = 2;}//  返回参数message TokenR {    bool IsLogin = 1;}//  定义服务Auth//  服务方法CheckToken//  Token传入的值//  TokenR输出的值//  生成兼容grpc的go文件//  protoc --go_out=plugins=grpc:. *.protoservice Auth {    rpc CheckToken (Token) returns (TokenR);}</code></pre><h1 id="生成兼容grpc的go文件"><a href="#生成兼容grpc的go文件" class="headerlink" title="生成兼容grpc的go文件"></a>生成兼容grpc的go文件</h1><pre><code class="golang">protoc --go_out=plugins=grpc:. *.proto</code></pre><p>生成了对应的pb文件：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200710083457.png" alt=""></p><h1 id="编写服务端"><a href="#编写服务端" class="headerlink" title="编写服务端"></a>编写服务端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;net&quot;)type AuthImp struct {}func (a *AuthImp) CheckToken(ctx context.Context, token *study.Token) (*study.TokenR, error) {   s := token.JwtToken   fmt.Println(s)   /**   一些列处理   */   //数据的返回   res := new(study.TokenR)   res.IsLogin = true   return res, nil}func main() {   server := grpc.NewServer()   //注册   study.RegisterAuthServer(server, new(AuthImp))   lis, err := net.Listen(&quot;tcp&quot;, &quot;:8091&quot;)   if err != nil {      panic(err.Error())   }   _ = server.Serve(lis)}</code></pre><h1 id="编写客户端"><a href="#编写客户端" class="headerlink" title="编写客户端"></a>编写客户端</h1><pre><code class="golang">package mainimport (   &quot;context&quot;   &quot;fmt&quot;   study &quot;goStudy/grpc/grpc001/auth&quot;   &quot;google.golang.org/grpc&quot;   &quot;time&quot;)func main() {   //客户端连接   conn, err := grpc.Dial(&quot;localhost:8091&quot;, grpc.WithInsecure())   if err != nil {      panic(err.Error())   }   defer conn.Close()   authServiceClient := study.NewAuthClient(conn)   request := study.Token{      TimeStamp: time.Now().Unix(),      JwtToken:  &quot;3213213&quot;,   }   checkTokenClient, err := authServiceClient.CheckToken(context.Background(), &amp;request)   fmt.Println(checkTokenClient.IsLogin)}</code></pre><p>这样就完成了最简单的grpc功能。</p><p>这样的rpc接口只能在程序之间进行调用，但是我们最后的服务需要提供给用户使用，需要的是http请求。这里有几个方案进行解决：</p><blockquote><p>1.编写专门的提供http的web服务，web服务充当客户端，调用grpc。</p></blockquote><blockquote><p>2.使用GRPC Gateway: <a href="https://github.com/grpc-ecosystem/grpc-gateway/" target="_blank" rel="noopener">https://github.com/grpc-ecosystem/grpc-gateway/</a></p></blockquote><blockquote><p>3.使用第三方拓展：<a href="https://github.com/vaporz/turbo" target="_blank" rel="noopener">https://github.com/vaporz/turbo</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> grpc </tag>
            
            <tag> 微服务 </tag>
            
            <tag> protobuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现一致性Hash算法</title>
      <link href="/posts/golang/6a0c048e.html"/>
      <url>/posts/golang/6a0c048e.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 13:21:49 GMT+0800 (GMT+08:00) --><h1 id="什么是一致性Hash算法"><a href="#什么是一致性Hash算法" class="headerlink" title="什么是一致性Hash算法"></a>什么是一致性Hash算法</h1><p>一致性Hash算法是使用取模的方法，一致性Hash算法是对2^32取模，什么意思呢？简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1（即哈希值是一个32位无符号整形），整个哈希环如下：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709195951.png" alt=""></p><p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1</p><p>我们把这个由2的32次方个点组成的圆环称为hash环。</p><p>假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意</p><blockquote><p>hash(服务器A的IP地址) % 2^32</p></blockquote><p>通过上述公式算出的结果一定是一个0到2^32-1之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201526.png" alt=""></p><p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中。所以现在的hash环：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709201713.png" alt=""></p><p>这样我们的服务器就映射到了hash环上，现在我们同理也就可以把我们需要访问的对象也放在hash环上。</p><p>假设我们现在需要分别在三个服务器上放缓存的文件，我们就使用文件的名字作为计算hash的key：</p><blockquote><p>hash(文件名) % 2^32</p></blockquote><p>这样也能计算一个值，也就能映射到对应的hash环上。现在我们的hash环就变成了这个样子：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709202336.png" alt=""></p><p>计算出来了文件的hash值，下一步就是觉得那个服务器存储这个对象了。这里规定是：从计算出来的位置开始向顺时针方向遇到的第一个服务器，进行存储。所以这里文件就会存储在服务器B上。</p><p>这就是一致性hash算法。</p><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>这里我们假设，我们的服务器B突然失效了,我们上面例子中的文件就会存储到服务器c中，这样就算是缓存失效。但是这里服务器失效的是A,就对上面例子中的文件不会有任何的影响。使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。这就是一致性哈希算法所体现出的优点。</p><h1 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h1><p>理想情况下我们的3个服务器是如上图所示，均匀的分布在hash环上，但是理想往往和现实差距很大：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203438.png" alt=""></p><p>实际上映射中，服务器可能会被映射成这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709203659.png" alt=""></p><p>这种情况下缓存的对象很有可能大部分集中缓存在某一台服务器。这就很难受了。这就是hash环的偏斜。那么，我们应该怎样防止hash环的偏斜呢？</p><h1 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h1><p>虚拟节点就是来解决hash环偏斜的问题的。顾名思义就是在hash环上创建每个服务器的副本，是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点，创建副本后的hash环就变成了这样：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709204300.png" alt=""></p><p>这样就解决了偏移问题。虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p><h1 id="Golang中实现hash环"><a href="#Golang中实现hash环" class="headerlink" title="Golang中实现hash环"></a>Golang中实现hash环</h1><pre><code class="golang">package hashimport (    &quot;errors&quot;    &quot;hash/crc32&quot;    &quot;sort&quot;    &quot;strconv&quot;    &quot;sync&quot;)//声明新切片类型type units []uint32//返回切片长度func (x units) Len() int {    return len(x)}//比对两个数大小func (x units) Less(i, j int) bool {    return x[i] &lt; x[j]}//切片中两个值的交换func (x units) Swap(i, j int) {    x[i], x[j] = x[j], x[i]}//创建结构体保存一致性hash信息type ConsistentHash struct {    //hash环，key为哈希值，值存放节点的信息    circle map[uint32]string    //已经排序的节点hash切片    sortedHashes units    //虚拟节点个数，用来增加hash的平衡性    VirtualNode int    //map 读写锁    sync.RWMutex}//创建一致性hash算法结构体，设置默认节点数量func NewConsistent(nodeNum int) *ConsistentHash {    return &amp;ConsistentHash{        //初始化变量        circle: make(map[uint32]string),        //设置虚拟节点个数        VirtualNode: nodeNum,    }}//自动生成key值func (c *ConsistentHash) generateKey(element string, index int) string {    //副本key生成逻辑    return element + strconv.Itoa(index)}//获取hash位置 计算key 在hash环中对应的位置func (c *ConsistentHash) hashKey(key string) uint32 {    //当长度不够填充    if len(key) &lt; 64 {        //声明一个数组长度为64        var tmpList [64]byte        //拷贝数据到数组中        copy(tmpList[:], key)        //使用IEEE 多项式返回数据的CRC-32校验和        return crc32.ChecksumIEEE(tmpList[:len(key)])    }    return crc32.ChecksumIEEE([]byte(key))}//更新排序，方便查找 因为后面我们使用的是sort.Search进行查找 sort.Search使用的是二分法进行查找，所以这里需要排序func (c *ConsistentHash) updateSortedHashes() {    hashes := c.sortedHashes[:0]    //判断切片容量，是否过大，如果过大则重置    if cap(c.sortedHashes)/(c.VirtualNode*4) &gt; len(c.circle) {        hashes = nil    }    //添加hashes    for k := range c.circle {        hashes = append(hashes, k)    }    //对所有节点hash值进行排序，    //方便之后进行二分查找    sort.Sort(hashes)    //重新赋值    c.sortedHashes = hashes}//向hash环中添加节点func (c *ConsistentHash) Add(element string) {    //加锁    c.Lock()    //解锁    defer c.Unlock()    c.add(element)}//添加节点func (c *ConsistentHash) add(element string) {    //循环虚拟节点，设置副本    for i := 0; i &lt; c.VirtualNode; i++ {        //根据生成的节点添加到hash环中        c.circle[c.hashKey(c.generateKey(element, i))] = element    }    //更新排序    c.updateSortedHashes()}//删除节点func (c *ConsistentHash) remove(element string) {    for i := 0; i &lt; c.VirtualNode; i++ {        delete(c.circle, c.hashKey(c.generateKey(element, i)))    }    c.updateSortedHashes()}//删除一个节点func (c *ConsistentHash) Remove(element string) {    c.Lock()    defer c.Unlock()    c.remove(element)}//顺时针查找最近的节点func (c *ConsistentHash) search(key uint32) int {    //查找算法    f := func(x int) bool {        return c.sortedHashes[x] &gt; key    }    //使用&quot;二分查找&quot;算法来搜索指定切片满足条件的最小值    i := sort.Search(len(c.sortedHashes), f)    //如果超出范围则设置i=0    if i &gt;= len(c.sortedHashes) {        i = 0    }    return i}//根据数据标示获取最近的服务器节点信息func (c *ConsistentHash) Get(name string) (string, error) {    //添加锁    c.RLock()    //解锁    defer c.RUnlock()    //如果为零则返回错误    if len(c.circle) == 0 {        return &quot;&quot;, errors.New(&quot;hash环没有数据&quot;)    }    //计算hash值    key := c.hashKey(name)    i := c.search(key)    return c.circle[c.sortedHashes[i]], nil}</code></pre><p>这样就很简单的实现了golong的一致性hash。</p><blockquote><p>这里提一下，为什么是2^32呢?因为这个算法的出现就算为了解决分布式问题，所以在分布式中基本上存储的就算服务器的ip，IPv4的地址是4组8位2进制数组成，所以用2^32可以保证每个IP地址会有唯一的映射。</p></blockquote><p>参考连接：<a href="https://www.cnblogs.com/williamjie/p/9477852.html" target="_blank" rel="noopener">https://www.cnblogs.com/williamjie/p/9477852.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
            <tag> 一致性Hash </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现依赖注入+gin</title>
      <link href="/posts/golang/8f49d9e3.html"/>
      <url>/posts/golang/8f49d9e3.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 11:10:46 GMT+0800 (GMT+08:00) --><h1 id="Go实现依赖注入"><a href="#Go实现依赖注入" class="headerlink" title="Go实现依赖注入"></a>Go实现依赖注入</h1><p>最近在使用go开发的时候，发现构建系统依赖树非常繁琐，需要手动去new很多对象，又手工代码将它们拼接起来，写了一堆非常冗繁的代码。之前在laravel的使用中有其强大的ioc，都没有这方面的困扰。就在想golang中有没有好用的依赖注入方案，查询资料，发现了facebook团队开源的inject。GitHub地址：<a href="http://github.com/facebookgo/inject" target="_blank" rel="noopener">http://github.com/facebookgo/inject</a></p><p>没有依赖注入的系统：<br><img src="https://gitee.com/myxy99/pic/raw/master/img/20200709104638.png" alt=""></p><p>在代码上的表现：</p><pre><code class="golang">func NewUserRepository() UserRepositoryImp {    return &amp;UserManagerRepository{        Db: models.MysqlHandler,    }}func NewUserServices(repository repositories.UserRepositoryImp) UserServiceImp {    return &amp;UserService{repository}}func NewUserController(userServices services.UserServiceImp) UserImp {    return &amp;UserController{UserServices: userServices}}repository := repositories.NewUserRepository()userServices := services.NewUserServices(repository)controller := controllers.NewUserController(userServices)</code></pre><p>这里也能看出口想当的难受。而且重复代码很多。</p><h2 id="使用的依赖"><a href="#使用的依赖" class="headerlink" title="使用的依赖"></a>使用的依赖</h2><pre><code class="golang">go get github.com/facebookgo/inject</code></pre><h2 id="简单的使用例子"><a href="#简单的使用例子" class="headerlink" title="简单的使用例子"></a>简单的使用例子</h2><pre><code class="golang">type DBEngine struct {    Name string}type UserDB struct {    Db *DBEngine `inject:&quot;&quot;`}type UserService struct {    Db *UserDB `inject:&quot;&quot;`}type App struct {    Name string    User *UserService `inject:&quot;&quot;`}func (a *App) Create() string {    return &quot;create app, in db name:&quot; + a.User.Db.Db.Name + &quot; app name :&quot; + a.Name}type Object struct {    App *App}func Init() *Object {    var g inject.Graph    // 不适用依赖注入    //a := DBEngine{Name: &quot;db1&quot;}    //b := UserDB{&amp;a}    //c := UserService{&amp;b}    //app := App{Name: &quot;go-app&quot;, User: &amp;c}    app := App{Name: &quot;go-app&quot;}    _ = g.Provide(        &amp;inject.Object{Value: &amp;DBEngine{Name: &quot;db1&quot;}},        &amp;inject.Object{Value: &amp;app},    )    _ = g.Populate()    return &amp;Object{        App: &amp;app,    }}func TestMains(t *testing.T) {    obj := Init()    fmt.Println(obj.App.Create())}</code></pre><p>这样很简单就实现了golang的依赖注入，看这个开源库的源码发现，整个类库的实现才500多行代码。这是多么轻量级的一个类库，只不过代码这么短，功能也不会太多，相比laravel的依赖注入而言，它的功能就单一太多了。不过没关系，相比Guice而言这些缺失的功能不是必须的，能帮我们省掉很多代码它已经做得很好了，这就足够了。</p><p>所以最上面的代码就可以修改为：</p><pre><code class="golang">    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()</code></pre><h2 id="在gin使用依赖注入"><a href="#在gin使用依赖注入" class="headerlink" title="在gin使用依赖注入"></a>在gin使用依赖注入</h2><pre><code class="golang">func TestInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //使用 Inject New方法就不用写了    var userController controllers.UserController    var injector inject.Graph    _ = injector.Provide(        &amp;inject.Object{Value: &amp;repositories.UserManagerRepository{Db: models.MysqlHandler}},        &amp;inject.Object{Value: &amp;services.UserService{}},        &amp;inject.Object{Value: &amp;userController},    )    _ = injector.Populate()    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, userController.Login)        api.POST(&quot;/register&quot;, userController.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), userController.Info)    }    _ = app.Run(&quot;:8080&quot;)}func TestNoInject(t *testing.T) {    models.Init()    models.MysqlHandler.AutoMigrate(models.User{})    //不使用 Inject    repository := repositories.NewUserRepository()    userServices := services.NewUserServices(repository)    controller := controllers.NewUserController(userServices)    app := gin.Default()    api := app.Group(&quot;/api&quot;)    {        api.POST(&quot;/login&quot;, controller.Login)        api.POST(&quot;/register&quot;, controller.Register)        api.GET(&quot;/me&quot;, middleware.Auth(), controller.Info)    }    _ = app.Run(&quot;:8080&quot;)}</code></pre><p>源码：<a href="https://github.com/myxy99/shopping" target="_blank" rel="noopener">https://github.com/myxy99/shopping</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> inject </tag>
            
            <tag> gin </tag>
            
            <tag> 依赖注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现RabbitMQ五种模式</title>
      <link href="/posts/golang/4b90efe7.html"/>
      <url>/posts/golang/4b90efe7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Thu Jul 09 2020 11:07:22 GMT+0800 (GMT+08:00) --><h1 id="使用的依赖包"><a href="#使用的依赖包" class="headerlink" title="使用的依赖包"></a>使用的依赖包</h1><pre><code class="golang">github.com/streadway/amqp</code></pre><h1 id="创建RabbitMQ实例"><a href="#创建RabbitMQ实例" class="headerlink" title="创建RabbitMQ实例"></a>创建RabbitMQ实例</h1><pre><code class="golang">package RabbitMQimport (    &quot;fmt&quot;    &quot;github.com/streadway/amqp&quot;    &quot;log&quot;)// 用户名 密码 ip:端口/虚拟机const MQURL = &quot;amqp://admin:123456@127.0.0.1:5672/test&quot;type RabbitMQ struct {    conn    *amqp.Connection    channel *amqp.Channel    //队列名称    QueueName string    //交换机    Exchange string    //key    key string    //连接信息    MqUrl string}//创建RabbitMQ结构体实例func NewRabbitMQ(queueName, exchange, key string) *RabbitMQ {    rabbitmq := &amp;RabbitMQ{QueueName: queueName, Exchange: exchange, key: key, MqUrl: MQURL}    var err error    //创建RabbitMQ连接    rabbitmq.conn, err = amqp.Dial(rabbitmq.MqUrl)    rabbitmq.failOnErr(err, &quot;创建连接错误!&quot;)    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;获取channel失败!&quot;)    return rabbitmq}//断开channel和connectionfunc (r *RabbitMQ) Destroy() {    r.channel.Close()    r.conn.Close()}//错误处理函数func (r *RabbitMQ) failOnErr(err error, message string) {    if err != nil {        log.Fatalf(&quot;%s:%s&quot;, message, err)        panic(fmt.Sprintf(&quot;%s,%s&quot;, message, err))    }}</code></pre><h1 id="Simple模式"><a href="#Simple模式" class="headerlink" title="Simple模式"></a>Simple模式</h1><p>Simple模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708092914.png" alt="Simple模式"></p><pre><code class="golang">//创建简单模式下RabbitMQ实例func NewRabbitMQSimple(queueName string) *RabbitMQ {    return NewRabbitMQ(queueName, &quot;&quot;, &quot;&quot;)}//简单模式下生产代码func (r *RabbitMQ) PublishSimple(message string) {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil,    )    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.发送消息到队列中    err = r.channel.Publish(        r.Exchange,        r.QueueName,        //如果为true,根据exchange类型和routekey规则,如果无法找到符合条件的队列那么会把发送的消息返回给发送者        false,        //如果为true,当exchange发送消息队列到队列后发现队列上没有绑定消费者,则会把消息发还给发送者        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })    if err != nil {        fmt.Println(&quot;Publish:&quot;, err)    }}//简单模式下消费代码func (r *RabbitMQ) ConsumeSimple() {    //1.申请队列,如果队列不存在会自动创建,如果存在则跳过创建    //保证队列存在,消息队列能发送到队列中    _, err := r.channel.QueueDeclare(        r.QueueName,        //是否持久化        false,        //是否为自动删除        false,        //是否具有排他性        false,        //是否阻塞        false,        //额外属性        nil)    if err != nil {        fmt.Println(&quot;QueueDeclare:&quot;, err)    }    //2.接受消息    msgs, err := r.channel.Consume(        r.QueueName,        //用来区分多个消费者        &quot;&quot;,        //是否自动应答        true,        //是否具有排他性        false,        //如果设置为true,表示不能将同一个connection中发送消息传递给这个connection中的消费者        false,        //队列消费是否阻塞        false,        nil)    if err != nil {        fmt.Println(&quot;Consume:&quot;, err)    }    forever := make(chan bool)    //3.启用协程处理消息    go func() {        for d := range msgs {            //实现我们要处理的逻辑函数            log.Printf(&quot;Received a message:%s&quot;, d.Body)        }    }()    log.Printf(&quot;[*] Waiting for messages,To exit press CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="简单模式publish"><a href="#简单模式publish" class="headerlink" title="简单模式publish"></a>简单模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;go-rabbitmq/RabbitMQ&quot;)func main()  {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.PublishSimple(&quot;myxy99.cn msg&quot;)    fmt.Println(&quot;发送成功!&quot;)}</code></pre><h2 id="简单模式recevie"><a href="#简单模式recevie" class="headerlink" title="简单模式recevie"></a>简单模式recevie</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="Work模式"><a href="#Work模式" class="headerlink" title="Work模式"></a>Work模式</h1><p>Work模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708093050.png" alt="Work模式"></p><p>simple模式和work模式其实用的是一套逻辑代码，只是work模式是可以有多个消费者的，work模式起到一个负载均衡的作用。</p><h2 id="work模式publish"><a href="#work模式publish" class="headerlink" title="work模式publish"></a>work模式publish</h2><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    for i := 0; i &lt;= 100; i++ {        rabbitmq.PublishSimple(&quot;Hello test!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="work模式receive1"><a href="#work模式receive1" class="headerlink" title="work模式receive1"></a>work模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h2 id="work模式receive2"><a href="#work模式receive2" class="headerlink" title="work模式receive2"></a>work模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQSimple(&quot;test&quot;)    rabbitmq.ConsumeSimple()}</code></pre><h1 id="订阅模式"><a href="#订阅模式" class="headerlink" title="订阅模式"></a>订阅模式</h1><p>订阅模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708095831.png" alt=""></p><p>订阅模式的特别是：一个消息被投递到多个队列，一个消息能被多个消费者获取。过程是由生产者将消息发送到exchange(交换机）里，然后exchange通过一系列的规则发送到队列上，然后由绑定对应的消费者进行消息。</p><pre><code class="golang">//订阅模式创建RabbitMQ实例func NewRabbitMQPubSub(exchangeName string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,&quot;&quot;)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//订阅模式生产func (r *RabbitMQ) PublishPub(message string) {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        &quot;fanout&quot;,        true,        false,        //true表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        &quot;&quot;,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//订阅模式消费端代码func (r *RabbitMQ) RecieveSub() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;fanout&quot;,        true,        false,        //YES表示这个exchange不可以被client用来推送消息，仅用来进行exchange和exchange之间的绑定        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        &quot;&quot;,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="订阅模式publish"><a href="#订阅模式publish" class="headerlink" title="订阅模式publish"></a>订阅模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    for i := 0; i &lt; 100; i++ {        rabbitmq.PublishPub(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        fmt.Println(&quot;订阅模式生产第&quot; +            strconv.Itoa(i) + &quot;条&quot; + &quot;数据&quot;)        time.Sleep(1 * time.Second)    }}</code></pre><h2 id="订阅模式receive1"><a href="#订阅模式receive1" class="headerlink" title="订阅模式receive1"></a>订阅模式receive1</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h2 id="订阅模式receive2"><a href="#订阅模式receive2" class="headerlink" title="订阅模式receive2"></a>订阅模式receive2</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main() {    rabbitmq := RabbitMQ.NewRabbitMQPubSub(&quot;newProduct&quot;)    rabbitmq.RecieveSub()}</code></pre><h1 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h1><p>路由模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100024.png" alt=""></p><p>路由模式:一个消息由多个消费者消费的基础上指定由哪些消息者来消费。</p><pre><code class="golang">func NewRabbitMQRouting(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//路由模式发送消息func (r *RabbitMQ) PublishRouting(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成direct        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exchange&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//路由模式接受消息func (r *RabbitMQ) RecieveRouting() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;direct&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //需要绑定key        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="路由模式publish"><a href="#路由模式publish" class="headerlink" title="路由模式publish"></a>路由模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishRouting(&quot;Hello myxy99 one!&quot; + strconv.Itoa(i))        mqTwo.PublishRouting(&quot;Hello myxy99 Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="路由模式receive-one"><a href="#路由模式receive-one" class="headerlink" title="路由模式receive-one"></a>路由模式receive-one</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_one&quot;)    mq.RecieveRouting()}</code></pre><h2 id="路由模式receive-two"><a href="#路由模式receive-two" class="headerlink" title="路由模式receive-two"></a>路由模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQRouting(&quot;myxy99&quot;,&quot;myxy99_two&quot;)    mq.RecieveRouting()}</code></pre><h1 id="话题模式"><a href="#话题模式" class="headerlink" title="话题模式"></a>话题模式</h1><p>话题模式工作流程：</p><p><img src="https://gitee.com/myxy99/pic/raw/master/img/20200708100143.png" alt=""></p><p>话题模式：话题模式是在路由模式上演化而来。不同的是我们以通配符的方式来指定我们的消费者。</p><pre><code class="golang">//话题模式//创建RabbitMQ实例func NewRabbitMQTopic(exchangeName string,routingKey string) *RabbitMQ {    //创建RabbitMQ实例    rabbitmq := NewRabbitMQ(&quot;&quot;,exchangeName,routingKey)    var err error    //获取connection    rabbitmq.conn, err = amqp.Dial(rabbitmq.Mqurl)    rabbitmq.failOnErr(err,&quot;failed to connect rabbitmq!&quot;)    //获取channel    rabbitmq.channel, err = rabbitmq.conn.Channel()    rabbitmq.failOnErr(err, &quot;failed to open a channel&quot;)    return rabbitmq}//话题模式发送消息func (r *RabbitMQ) PublishTopic(message string )  {    //1.尝试创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //要改成topic        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an excha&quot;+        &quot;nge&quot;)    //2.发送消息    err = r.channel.Publish(        r.Exchange,        //要设置        r.Key,        false,        false,        amqp.Publishing{            ContentType: &quot;text/plain&quot;,            Body:        []byte(message),        })}//话题模式接受消息//要注意key,规则//其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个）//匹配 myxy99.* 表示匹配 myxy99.hello, 但是myxy99.hello.one需要用myxy99.#才能匹配到func (r *RabbitMQ) RecieveTopic() {    //1.试探性创建交换机    err := r.channel.ExchangeDeclare(        r.Exchange,        //交换机类型        &quot;topic&quot;,        true,        false,        false,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare an exch&quot;+        &quot;ange&quot;)    //2.试探性创建队列，这里注意队列名称不要写    q, err := r.channel.QueueDeclare(        &quot;&quot;, //随机生产队列名称        false,        false,        true,        false,        nil,    )    r.failOnErr(err, &quot;Failed to declare a queue&quot;)    //绑定队列到 exchange 中    err = r.channel.QueueBind(        q.Name,        //在pub/sub模式下，这里的key要为空        r.Key,        r.Exchange,        false,        nil)    //消费消息    messges, err := r.channel.Consume(        q.Name,        &quot;&quot;,        true,        false,        false,        false,        nil,    )    forever := make(chan bool)    go func() {        for d := range messges {            log.Printf(&quot;Received a message: %s&quot;, d.Body)        }    }()    fmt.Println(&quot;退出请按 CTRL+C\n&quot;)    &lt;-forever}</code></pre><h2 id="话题模式publish"><a href="#话题模式publish" class="headerlink" title="话题模式publish"></a>话题模式publish</h2><pre><code class="golang">package mainimport (    &quot;rabbitmq/RabbitMQ&quot;    &quot;strconv&quot;    &quot;time&quot;    &quot;fmt&quot;)func main()  {    mqOne:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.one&quot;)    mqTwo:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.topic.two&quot;)    for i := 0; i &lt;= 10; i++ {        mqOne.PublishTopic(&quot;Hello myxy99 topic one!&quot; + strconv.Itoa(i))        mqTwo.PublishTopic(&quot;Hello myxy99 topic Two!&quot; + strconv.Itoa(i))        time.Sleep(1 * time.Second)        fmt.Println(i)    }}</code></pre><h2 id="话题模式receive-all"><a href="#话题模式receive-all" class="headerlink" title="话题模式receive-all"></a>话题模式receive-all</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;#&quot;)    mq.RecieveTopic()}</code></pre><h2 id="话题模式receive-two"><a href="#话题模式receive-two" class="headerlink" title="话题模式receive-two"></a>话题模式receive-two</h2><pre><code class="golang">package mainimport &quot;rabbitmq/RabbitMQ&quot;func main()  {    mq:=RabbitMQ.NewRabbitMQTopic(&quot;myxy99Topic&quot;,&quot;myxy99.*.two&quot;)    mq.RecieveTopic()}</code></pre><p>GitHub地址：<a href="https://github.com/myxy99/Go-RabbitMQ" target="_blank" rel="noopener">https://github.com/myxy99/Go-RabbitMQ</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang-Redis简易封装</title>
      <link href="/posts/golang/b9458491.html"/>
      <url>/posts/golang/b9458491.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 08 2020 07:06:51 GMT+0800 (GMT+08:00) --><h1 id="Golang-Redis"><a href="#Golang-Redis" class="headerlink" title="Golang Redis"></a>Golang Redis</h1><h2 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h2><pre><code class="golang">go get github.com/gomodule/redigo</code></pre><h2 id="Redis-操作封装"><a href="#Redis-操作封装" class="headerlink" title="Redis 操作封装"></a>Redis 操作封装</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><pre><code class="ini">[redis]Host = 127.0.0.1:6379Password =MaxIdle = 30MaxActive = 30IdleTimeout = 200</code></pre><h3 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h3><pre><code class="golang">package Redisimport (    &quot;encoding/json&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;github.com/gomodule/redigo/redis&quot;)//定义redis连接池var Conn *redis.Pool//初始化func InitRedis() error {    Conn = &amp;redis.Pool{        MaxIdle:     Config.RedisSetting.MaxIdle,        MaxActive:   Config.RedisSetting.MaxActive,        IdleTimeout: Config.RedisSetting.IdleTimeout,        Dial: func() (redis.Conn, error) {            c, err := redis.Dial(&quot;tcp&quot;, Config.RedisSetting.Host)            if err != nil {                return nil, err            }            if Config.RedisSetting.Password != &quot;&quot; {                if _, err := c.Do(&quot;AUTH&quot;, Config.RedisSetting.Password); err != nil {                    _ = c.Close()                    return nil, err                }            }            return c, err        },        TestOnBorrow: func(c redis.Conn, t time.Time) error {            _, err := c.Do(&quot;PING&quot;)            return err        },    }    return nil}//redis 设置函数func Set(key string, data interface{}, time int) (bool, error) {    conn := Conn.Get()    defer conn.Close()    value, err := json.Marshal(data)    if err != nil {        return false, err    }    reply, err := redis.String(conn.Do(&quot;SET&quot;, key, value))    _, _ = conn.Do(&quot;EXPIRE&quot;, key, time)    return reply == &quot;OK&quot;, err}//redis 检测存在函数func Exists(key string) bool {    conn := Conn.Get()    defer conn.Close()    exists, err := redis.Bool(conn.Do(&quot;EXISTS&quot;, key))    if err != nil {        return false    }    return exists}//redis 获取函数func Get(key string) ([]byte, error) {    conn := Conn.Get()    defer conn.Close()    reply, err := redis.Bytes(conn.Do(&quot;GET&quot;, key))    if err != nil {        return nil, err    }    return reply, nil}//redis 删除函数func Delete(key string) (bool, error) {    conn := Conn.Get()    defer conn.Close()    return redis.Bool(conn.Do(&quot;DEL&quot;, key))}//redis 模糊删除函数func LikeDeletes(key string) error {    conn := Conn.Get()    defer conn.Close()    keys, err := redis.Strings(conn.Do(&quot;KEYS&quot;, &quot;*&quot;+key+&quot;*&quot;))    if err != nil {        return err    }    for _, key := range keys {        _, err = Delete(key)        if err != nil {            return err        }    }    return nil}</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="golang">if err := Redis.InitRedis(); err != nil {    log.Println(&quot;init redis failed, err:&quot; + err.Error())    return}</code></pre><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code class="golang">...if Redis.Exists(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...if Redis.Get(&quot;Register_&quot; + s.Email) {    return R.SENDCODE_EXISTS, false}...</code></pre><p>使用很简单这里就不一一举例了。通过这样的封装redis操作就变得更加简单了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang使用jwt</title>
      <link href="/posts/golang/631d0e90.html"/>
      <url>/posts/golang/631d0e90.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Jul 08 2020 07:06:51 GMT+0800 (GMT+08:00) --><h1 id="Golang中使用JWT-json-web-token"><a href="#Golang中使用JWT-json-web-token" class="headerlink" title="Golang中使用JWT(json web token)"></a>Golang中使用JWT(json web token)</h1><h2 id="什么是jwt"><a href="#什么是jwt" class="headerlink" title="什么是jwt"></a>什么是jwt</h2><p>什么是jwt这里就不多说了，官网有介绍。官网介绍：<a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="下载依赖包"><a href="#下载依赖包" class="headerlink" title="下载依赖包"></a>下载依赖包</h3><pre><code class="golang">go get -u github.com/dgrijalva/jwt-go</code></pre><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="ini">[jwt]# 盐JwtSecret = jdnsakjbduiiudu# 过期时间（天ExpiresAt = 3# 签发Issuer = jwt</code></pre><h4 id="golang代码"><a href="#golang代码" class="headerlink" title="golang代码"></a>golang代码</h4><pre><code class="golang">package Utilsimport (    &quot;errors&quot;    &quot;github.com/dgrijalva/jwt-go&quot;    &quot;time&quot;    &quot;wPan/v1/Config&quot; //加载配置    &quot;wPan/v1/Models&quot; //加载模型)// JWT 签名结构type JWT struct {    SigningKey []byte}//JWT 中存储得数据结构体 这里可以根据需求自由添加type UserInfo struct {    Id       int    `json:&quot;id&quot;`    Username string `json:&quot;username&quot;`    Email    string `json:&quot;email&quot;`    Status   int    `json:&quot;status&quot;`}// 生成JWT函数func GenerateToken(user *Models.User) (string, error) {    claim := jwt.MapClaims{        //这里为自定义        &quot;username&quot;: user.UserName,        &quot;id&quot;:       user.ID,        &quot;email&quot;:    user.Email,        &quot;status&quot;:   user.Status,        //到这里，后面都是必须的        &quot;nbf&quot;: time.Now().Unix(),        &quot;iat&quot;: time.Now().Unix(),        //设置过期时间        &quot;exp&quot;: time.Now().Unix() + Config.JWTSetting.ExpiresAt*60*60,        //签名方        &quot;iss&quot;: Config.JWTSetting.Issuer,    }    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)    tokens, err := token.SignedString([]byte(Config.JWTSetting.JwtSecret))    return tokens, err}//设置盐func secret() jwt.Keyfunc {    return func(token *jwt.Token) (interface{}, error) {        return []byte(Config.JWTSetting.JwtSecret), nil    }}//token 验证func ParseToken(tokens string) (user *UserInfo, err error) {    user = &amp;UserInfo{}    token, err := jwt.Parse(tokens, secret())    if err != nil {        return    }    claim, ok := token.Claims.(jwt.MapClaims)    if !ok {        err = errors.New(&quot;cannot convert claim to mapclaim&quot;)        return    }    //验证token，如果token被修改过则为false    if !token.Valid {        err = errors.New(&quot;token is invalid&quot;)        return    }    //提取当初我们生成时候存储的数据    user.Id = int(claim[&quot;id&quot;].(float64))    user.Username = claim[&quot;username&quot;].(string)    user.Email = claim[&quot;email&quot;].(string)    user.Status = int(claim[&quot;status&quot;].(float64))    return}</code></pre><p>Service中的使用</p><pre><code class="golang">func GetJwt(u *Models.User) (string, bool) {    token, err := Utils.GenerateToken(u)    if err != nil {        return &quot;&quot;, false    }    return token, true}</code></pre><h4 id="编写验证中间件"><a href="#编写验证中间件" class="headerlink" title="编写验证中间件"></a>编写验证中间件</h4><p>我这里使用的gin框架，其他的框架也类似</p><pre><code class="golang">func Auth() gin.HandlerFunc {    return func(c *gin.Context) {        token := c.GetHeader(&quot;Authorization&quot;)        userInfo, err := Utils.ParseToken(token[7:])        if err != nil {            R.Response(c, http.StatusUnauthorized, R.AUTH_ERROR, nil, http.StatusUnauthorized)            c.Abort()            return        }        c.Set(&quot;userInfo&quot;, userInfo)        c.Next()        return    }}</code></pre><h4 id="路由中使用"><a href="#路由中使用" class="headerlink" title="路由中使用"></a>路由中使用</h4><pre><code class="golang">authApi.GET(&quot;/info&quot;, Middleware.Auth(), Controllers.Info)</code></pre><p>这样用户再访问需要验证的请求时，就需要请求头中带上<code>Authorization</code>，value为token。</p><p>参考连接：<a href="https://github.com/dgrijalva/jwt-go" target="_blank" rel="noopener">https://github.com/dgrijalva/jwt-go</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang邮件发送</title>
      <link href="/posts/golang/4db013d1.html"/>
      <url>/posts/golang/4db013d1.html</url>
      
        <content type="html"><![CDATA[<h1 id="golang发送邮件"><a href="#golang发送邮件" class="headerlink" title="golang发送邮件"></a>golang发送邮件</h1><h2 id="安装库"><a href="#安装库" class="headerlink" title="安装库"></a>安装库</h2><pre><code class="golang">go get github.com/jordan-wright/email</code></pre><h2 id="简单代码实现"><a href="#简单代码实现" class="headerlink" title="简单代码实现"></a>简单代码实现</h2><pre><code class="golang">package mainimport (    &quot;log&quot;    &quot;net/smtp&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    e := email.NewEmail()    //设置发送方的邮箱    e.From = &quot;112233 &lt;XXX@qq.com&gt;&quot;    // 设置接收方的邮箱    e.To = []string{&quot;XXX@qq.com&quot;}    //设置主题    e.Subject = &quot;这是主题&quot;    //设置文件发送的内容    e.Text = []byte(&quot;发送的内容&quot;)    //设置服务器相关的配置    err := e.Send(&quot;smtp.qq.com:25&quot;, smtp.PlainAuth(&quot;&quot;, &quot;你的邮箱账号&quot;, &quot;这块是你的授权码&quot;, &quot;smtp.qq.com&quot;))    if err != nil {       ....    }}</code></pre><h2 id="实现抄送功能"><a href="#实现抄送功能" class="headerlink" title="实现抄送功能"></a>实现抄送功能</h2><pre><code class="golang">func main() {    ...    //设置抄送如果抄送多人逗号隔开    e.Cc = []string{&quot;XXX@qq.com&quot;,XXX@qq.com}    //设置秘密抄送    e.Bcc = []string{&quot;XXX@qq.com&quot;}    ...}</code></pre><h2 id="发送html代码的邮件"><a href="#发送html代码的邮件" class="headerlink" title="发送html代码的邮件"></a>发送html代码的邮件</h2><pre><code class="golang">func main() {    ...    e.HTML = []byte(`    &lt;h1&gt;&lt;a href=&quot;http://www.baidu.com/&quot;&gt;百度&lt;/a&gt;&lt;/h1&gt;        `)    ...}</code></pre><h2 id="实现邮件附件的发送"><a href="#实现邮件附件的发送" class="headerlink" title="实现邮件附件的发送"></a>实现邮件附件的发送</h2><pre><code class="golang">func main() {    ...    e.AttachFile(&quot;./test.txt&quot;)    ...}</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>每次调用Send时都会和 SMTP 服务器建立一次连接，如果发送邮件很多很频繁的话可能会有性能问题。email提供了连接池，可以复用网络连接：</p><pre><code class="golang">package mainimport (    &quot;fmt&quot;    &quot;log&quot;    &quot;net/smtp&quot;    &quot;os&quot;    &quot;sync&quot;    &quot;time&quot;    &quot;github.com/jordan-wright/email&quot;)func main() {    ch := make(chan *email.Email, 10)    p, err := email.NewPool(        &quot;smtp.qq.com:25&quot;,        4,        smtp.PlainAuth(&quot;&quot;, &quot;XXX@qq.com&quot;, &quot;你的授权码&quot;, &quot;smtp.qq.com&quot;),    )    if err != nil {        log.Fatal(&quot;failed to create pool:&quot;, err)    }    var wg sync.WaitGroup    wg.Add(4)    for i := 0; i &lt; 4; i++ {        go func() {            defer wg.Done()            for e := range ch {                err := p.Send(e, 10*time.Second)                if err != nil {                    fmt.Fprintf(os.Stderr, &quot;email:%v sent error:%v\n&quot;, e, err)                }            }        }()    }    for i := 0; i &lt; 10; i++ {        e := email.NewEmail()        e.From = &quot;dj &lt;XXX@qq.com&gt;&quot;        e.To = []string{&quot;XXX@qq.com&quot;}        e.Subject = &quot;Awesome web&quot;        e.Text = []byte(fmt.Sprintf(&quot;Awesome Web %d&quot;, i+1))        ch &lt;- e    }    close(ch)    wg.Wait()}</code></pre><p>上面程序中，我们创建 4 goroutine 共用一个连接池发送邮件，发送 10 封邮件后程序退出。为了等邮件都发送完成或失败，程序才退出，我们使用了sync.WaitGroup。由于使用了 goroutine，邮件顺序不能保证。</p><p>参考连接：<a href="https://github.com/darjun/go-daily-lib" target="_blank" rel="noopener">https://github.com/darjun/go-daily-lib</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/posts/jenkins/87b776c7.html"/>
      <url>/posts/jenkins/87b776c7.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 21:19:18 GMT+0800 (GMT+08:00) --><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出</p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/posts/golang/41aae1e1.html"/>
      <url>/posts/golang/41aae1e1.html</url>
      
        <content type="html"><![CDATA[<!-- build time:Sun Jul 12 2020 13:18:27 GMT+0800 (GMT+08:00) --><h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre><p>参考连接：<a href="https://www.cnblogs.com/blogbobo/p/13169714.html" target="_blank" rel="noopener">https://www.cnblogs.com/blogbobo/p/13169714.html</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
