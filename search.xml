<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jenkins插件安装提速</title>
      <link href="/2020-07-07/undefined/"/>
      <url>/2020-07-07/undefined/</url>
      
        <content type="html"><![CDATA[<h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p>配置Json其实在Jenkins的工作目录中</p><pre><code class="cmd">cd {你的Jenkins工作目录}/updates  #进入更新配置位置</code></pre><h2 id="第一种方式：使用vim"><a href="#第一种方式：使用vim" class="headerlink" title="第一种方式：使用vim"></a>第一种方式：使用vim</h2><pre><code class="cmd">vim default.json   #这个Json文件与上边的配置文件是相同的</code></pre><p>使用vim的命令，如下，替换所有插件下载的url</p><pre><code class="cmd">:1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</code></pre><p>替换连接测试url</p><pre><code class="cmd">:1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</code></pre><pre><code>进入vim先输入：然后再粘贴上边的：后边的命令，注意不要写两个冒号！</code></pre><p>修改完成保存退出 </p><pre><code class="cmd">:wq</code></pre><h2 id="第二种方式：使用sed"><a href="#第二种方式：使用sed" class="headerlink" title="第二种方式：使用sed"></a>第二种方式：使用sed</h2><p>在updates目录下</p><pre><code class="cmd">sed -i &#39;s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g&#39; default.json &amp;&amp; sed -i &#39;s/http:\/\/www.google.com/https:\/\/www.baidu.com/g&#39; default.json</code></pre><pre><code>这是直接修改的配置文件，如果前边Jenkins用sudo启动的话，那么这里的两个sed前均需要加上sudo</code></pre><p>重启Jenkins，简直超速！！</p>]]></content>
      
      
      <categories>
          
          <category> jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang实现雪花算法</title>
      <link href="/2020-07-07/undefined/"/>
      <url>/2020-07-07/undefined/</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h1><h2 id="雪花算法-1"><a href="#雪花算法-1" class="headerlink" title="雪花算法"></a>雪花算法</h2><p>雪花算法的原始版本是scala版，用于生成分布式ID（纯数字，时间顺序）,订单编号等<br>    自增ID：对于数据敏感场景不宜使用，且不适合于分布式场景。 GUID：采用无意义字符串，数据量增大时造成访问过慢，且不宜排序。</p><h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ul><li>最高位是符号位，始终为0，不可用。</li><li>41位的时间序列，精确到毫秒级，41位的长度可以使用69年。时间位还有一个很重要的作用是可以根据时间进行排序。</li><li>10位的机器标识，10位的长度最多支持部署1024个节点。</li><li>12位的计数序列号，序列号即一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号。</li></ul><h2 id="Golang-实现"><a href="#Golang-实现" class="headerlink" title="Golang 实现"></a>Golang 实现</h2><pre><code class="golang">package mainimport (    &quot;errors&quot;    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)const (    workerBits  uint8 = 10    numberBits  uint8 = 12    workerMax   int64 = -1 ^ (-1 &lt;&lt; workerBits)    numberMax   int64 = -1 ^ (-1 &lt;&lt; numberBits)    timeShift   uint8 = workerBits + numberBits    workerShift uint8 = numberBits    startTime   int64 = 1525705533000 // 如果在程序跑了一段时间修改了epoch这个值 可能会导致生成相同的ID)type Worker struct {    mu        sync.Mutex    timestamp int64    workerId  int64    number    int64}func NewWorker(workerId int64) (*Worker, error) {    if workerId &lt; 0 || workerId &gt; workerMax {        return nil, errors.New(&quot;Worker ID excess of quantity&quot;)    }    // 生成一个新节点    return &amp;Worker{        timestamp: 0,        workerId:  workerId,        number:    0,    }, nil}func (w *Worker) GetId() int64 {    w.mu.Lock()    defer w.mu.Unlock()    now := time.Now().UnixNano() / 1e6    if w.timestamp == now {        w.number++        if w.number &gt; numberMax {            for now &lt;= w.timestamp {                now = time.Now().UnixNano() / 1e6            }        }    } else {        w.number = 0        w.timestamp = now    }    ID := int64((now-startTime)&lt;&lt;timeShift | (w.workerId &lt;&lt; workerShift) | (w.number))    return ID}func main() {    // 生成节点实例    node, err := NewWorker(1)    if err != nil {        panic(err)    }    for {        fmt.Println(node.GetId())    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
